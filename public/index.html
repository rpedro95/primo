<!DOCTYPE html>
<html lang="pt">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Podcast Battle</title>
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#4a9eff">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Podcast Battle">
<link rel="apple-touch-icon" href="/img/icon-192.png">
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<style>
  body {
    font-family: Arial, sans-serif;
    background: #121212;
    color: #fff;
    margin: 0;
    padding: 2rem;
  }
  .grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 1.5rem;
  }
  .card {
    position: relative;
    border-radius: 1rem;
    cursor: pointer;
    overflow: hidden;
    height: 300px;
    transition: transform 0.2s ease;
  }
  .card:hover {
    transform: scale(1.02);
  }
  .card:active {
    transform: scale(0.98);
  }
  .card-front {
    position: relative;
    width: 100%;
    height: 300px;
    border-radius: 1rem;
    overflow: hidden;
    background-size: cover;
    background-position: center;
    filter: brightness(1);
    transition: filter 0.3s;
  }
  .card-front::after {
    content: 'Clica para avaliar';
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 5px 10px;
    border-radius: 15px;
    font-size: 12px;
    opacity: 0;
    transition: opacity 0.3s;
  }
  .card-front.front-inactive::after {
    content: 'Ainda n√£o saiu';
    background: rgba(255,0,0,0.7);
  }
  .card:hover .card-front::after {
    opacity: 1;
  }
  .card-front.front-inactive {
    filter: brightness(0.4) grayscale(80%);
  }
  .overlay {
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.6);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    border-radius: 1rem;
    padding: 1rem;
  }
  .overlay h3 {
    margin-bottom: 0.5rem;
  }
  .overlay button:hover {
    background: rgba(0,0,0,0.9) !important;
    transform: scale(1.05);
  }
  
  .card:hover .hover-content {
    opacity: 1 !important;
  }
  .stars span {
    font-size: 1.5rem;
    cursor: pointer;
    color: gold;
  }
</style>
</head>
<body>

<div class="grid" id="podcasts"></div>

<script>
let currentUser = localStorage.getItem('podcastUser');
let ws = null;

// Fun√ß√£o para conectar WebSocket
function connectWebSocket() {
  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  const wsUrl = `${protocol}//${window.location.host}`;
  
  ws = new WebSocket(wsUrl);
  
  ws.onopen = () => {
    console.log('WebSocket conectado');
    // Regista o utilizador atual
    if (currentUser) {
      ws.send(JSON.stringify({
        type: 'register',
        user: currentUser
      }));
    }
  };
  
  ws.onmessage = (event) => {
    const message = JSON.parse(event.data);
    
    if (message.type === 'registered') {
      console.log(`Registado como ${message.user} para notifica√ß√µes`);
    } else if (message.type === 'notification') {
      // S√≥ mostrar notifica√ß√£o se for para o utilizador atual
      if (message.targetUser === currentUser) {
        console.log(`üì® Notifica√ß√£o recebida para ${currentUser}`);
        showReceivedNotification(message);
      } else {
        console.log(`üì® Notifica√ß√£o ignorada (destinada a ${message.targetUser}, sou ${currentUser})`);
      }
    }
  };
  
  ws.onclose = () => {
    console.log('WebSocket desconectado, tentando reconectar...');
    // Tentar reconectar ap√≥s 3 segundos
    setTimeout(connectWebSocket, 3000);
  };
  
  ws.onerror = (error) => {
    console.error('Erro WebSocket:', error);
  };
}

// Fun√ß√£o para mostrar notifica√ß√£o recebida
function showReceivedNotification(notification) {
  const episodeText = notification.episodeNumber ? ` - Ep ${notification.episodeNumber}` : '';
  
  // Mostrar notifica√ß√£o nativa do browser
  if ('Notification' in window && Notification.permission === 'granted') {
    const notif = new Notification(`üéß ${notification.podcastName}${episodeText}`, {
      body: `${notification.fromUser} avaliou com ${notification.rating}/10: "${notification.message}"`,
      icon: '/img/notification-icon.png',
      tag: `notification-${notification.timestamp}`
    });
    
    // Fechar ap√≥s 8 segundos
    setTimeout(() => notif.close(), 8000);
  }
  
  // Mostrar tamb√©m um alerta SweetAlert
  Swal.fire({
    title: `üéß ${notification.podcastName}${episodeText}`,
    text: `${notification.fromUser} avaliou com ${notification.rating}/10: "${notification.message}"`,
    icon: 'info',
    timer: 5000,
    showConfirmButton: false,
    toast: true,
    position: 'top-end'
  });
}

// Pergunta quem est√° a usar se ainda n√£o existir
async function askUser() {
  const result = await Swal.fire({
    title: 'Quem est√° a usar?',
    showCancelButton: false,
    showDenyButton: true,
    confirmButtonText: 'Pedro',
    denyButtonText: 'Jo√£o',
    allowOutsideClick: false
  });
  currentUser = result.isConfirmed ? 'Pedro' : 'Jo√£o';
  localStorage.setItem('podcastUser', currentUser);
  
  // Conectar WebSocket ap√≥s sele√ß√£o do utilizador
  connectWebSocket();
}

// API para guardar rating
async function saveRating(podcastId, rating) {
  try {
    const requestData = { podcastId, user: currentUser, rating };
    console.log('Sending rating data:', requestData);
    
    const response = await fetch('/api/rate', {
      method: 'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify(requestData)
    });
    
    console.log('Response status:', response.status);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('Error response:', errorText);
      throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);
    }
    renderPodcasts();
  } catch (error) {
    console.error('Error saving rating:', error);
    alert('Erro ao guardar rating: ' + error.message);
  }
}

// API para limpar rating
async function clearRating(podcastId) {
  try {
    const response = await fetch('/api/rate', {
      method: 'DELETE',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify({ podcastId, user: currentUser })
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);
    }
    renderPodcasts();
  } catch (error) {
    console.error('Error clearing rating:', error);
    alert('Erro ao limpar rating: ' + error.message);
  }
}

// Fun√ß√£o para enviar notifica√ß√£o
async function sendNotificationToUser(targetUser, podcastName, rating, message, podcastId) {
  try {
    // Verificar se notifica√ß√µes est√£o dispon√≠veis
    if (!('Notification' in window)) {
      console.log('Este browser n√£o suporta notifica√ß√µes');
      return;
    }

    // Verificar se temos permiss√£o
    if (Notification.permission !== 'granted') {
      console.log('Permiss√£o para notifica√ß√µes negada');
      return;
    }

    // Enviar notifica√ß√£o via API
    const response = await fetch('/api/notify', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        targetUser,
        podcastName,
        rating,
        message,
        fromUser: currentUser,
        podcastId: podcastId
      })
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    // Mostrar notifica√ß√£o local tamb√©m
    const notification = new Notification(`üéß ${podcastName}`, {
      body: `${currentUser} avaliou com ${rating}/10: "${message}"`,
      icon: '/img/notification-icon.png', // Podes adicionar um √≠cone
      tag: `rating-${podcastName}-${Date.now()}`
    });

    // Fechar notifica√ß√£o ap√≥s 5 segundos
    setTimeout(() => {
      notification.close();
    }, 5000);

  } catch (error) {
    console.error('Error sending notification:', error);
    // N√£o mostrar erro ao utilizador para n√£o interromper o fluxo
  }
}

// Fun√ß√£o para mostrar popup de rating
async function showRatingPopup(podcast) {
  const otherUser = currentUser === 'Pedro' ? 'Jo√£o' : 'Pedro';
  const myRating = currentUser === 'Pedro' ? podcast.ratingPedro : podcast.ratingJoao;
  const otherRating = currentUser === 'Pedro' ? podcast.ratingJoao : podcast.ratingPedro;
  
  // Build ratings display - only show existing ratings
  let ratingsDisplay = '';
  if (myRating) {
    ratingsDisplay += `<div style="margin-bottom: 15px;"><strong>A tua nota:</strong> ${myRating}/10</div>`;
  }
  if (otherRating) {
    ratingsDisplay += `<div style="margin-bottom: 20px;"><strong>${otherUser}:</strong> ${otherRating}/10</div>`;
  }
  
  const result = await Swal.fire({
    title: `Avaliar: ${podcast.nome}`,
    html: `
      <div style="text-align: center; margin: 20px 0;">
        ${ratingsDisplay}
        <div style="margin-bottom: 10px;">
          <label for="rating-slider">Escolhe a tua nota (1-10):</label>
        </div>
        <input type="range" id="rating-slider" min="1" max="10" value="${myRating || 1}" 
               style="width: 100%; margin: 10px 0;">
        <div id="rating-display" style="font-size: 24px; font-weight: bold; color: #ffd700;">
          ${myRating || 1}/10
        </div>
        
        <div style="margin-top: 20px; padding: 15px; background: #f0f0f0; border-radius: 8px;">
          <div style="margin-bottom: 10px;">
            <input type="checkbox" id="send-notification" style="margin-right: 8px;">
            <label for="send-notification">Enviar notifica√ß√£o para ${otherUser}</label>
          </div>
          <div id="notification-section" style="display: none;">
            <textarea id="notification-message" placeholder="Escreve uma mensagem para ${otherUser}..." 
                      style="width: 100%; height: 60px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; resize: vertical;"></textarea>
          </div>
        </div>
      </div>
    `,
    showCancelButton: true,
    showDenyButton: myRating ? true : false,
    confirmButtonText: 'Guardar',
    denyButtonText: 'Apagar Nota',
    cancelButtonText: 'Cancelar',
    allowOutsideClick: false,
    didOpen: () => {
      const slider = document.getElementById('rating-slider');
      const display = document.getElementById('rating-display');
      const notificationCheckbox = document.getElementById('send-notification');
      const notificationSection = document.getElementById('notification-section');
      
      slider.addEventListener('input', (e) => {
        display.textContent = `${e.target.value}/10`;
      });
      
      notificationCheckbox.addEventListener('change', (e) => {
        notificationSection.style.display = e.target.checked ? 'block' : 'none';
      });
    },
    preConfirm: () => {
      const rating = parseInt(document.getElementById('rating-slider').value);
      const sendNotification = document.getElementById('send-notification').checked;
      const message = document.getElementById('notification-message').value;
      return { action: 'save', rating, sendNotification, message };
    }
  });

  if (result.isConfirmed) {
    // User clicked "Guardar"
    const rating = result.value.rating;
    const sendNotification = result.value.sendNotification;
    const message = result.value.message;
    
    await saveRating(podcast.id, rating);
    
    // Enviar notifica√ß√£o se solicitado
    if (sendNotification && message.trim()) {
      // Verificar se n√£o est√° a enviar para si mesmo
      if (otherUser !== currentUser) {
        await sendNotificationToUser(otherUser, podcast.nome, rating, message, podcast.id);
      } else {
        Swal.fire({
          title: 'Aviso!',
          text: 'N√£o podes enviar notifica√ß√£o para ti mesmo. Testa com dois browsers diferentes!',
          icon: 'warning'
        });
        return;
      }
    }
    
    Swal.fire({
      title: 'Nota guardada!',
      text: `Avaliaste "${podcast.nome}" com ${rating}/10${sendNotification && message.trim() ? ' e notifica√ß√£o enviada!' : ''}`,
      icon: 'success',
      timer: 2000,
      showConfirmButton: false
    });
  } else if (result.isDenied) {
    // User clicked "Apagar Nota"
    await clearRating(podcast.id);
    Swal.fire({
      title: 'Nota apagada!',
      text: `Removeste a tua nota de "${podcast.nome}"`,
      icon: 'info',
      timer: 2000,
      showConfirmButton: false
    });
  }
}

function imagePath(nome) {
  // Map podcast names to actual image filenames
  const imageMap = {
    'watch.tm': 'watch.tm',
    '√† noite mata': '√† noite mata',
    'desnorte': 'Desnorte',  // Capital D
    'Z√© Carioca': 'Z√© Carioca',
    'Cubinho': 'Cubinho',
    'Velho amigo': 'Velho Amigo',  // Capital V and A
    'Prata da Casa': 'Prata da Casa',
    'Contraluz': 'Contraluz',
    'Trocadilho': 'Trocadilho'
  };
  
  const filename = imageMap[nome] || nome;
  // Properly encode the URL to handle spaces and special characters
  const encodedFilename = encodeURIComponent(filename);
  const fullPath = `/img/${encodedFilename}.png`;
  return fullPath;
}

// Renderiza os podcasts
async function renderPodcasts() {
  try {
    const res = await fetch('/api/podcasts');
    
    if (!res.ok) {
      throw new Error(`HTTP error! status: ${res.status}`);
    }
    
    const data = await res.json();
    const grid = document.getElementById('podcasts');
    if (!grid) {
      throw new Error('Podcasts grid element not found');
    }
    
    grid.innerHTML = '';

    if (!data.podcasts || data.podcasts.length === 0) {
      grid.innerHTML = '<p>Nenhum podcast encontrado</p>';
      return;
    }

    data.podcasts.forEach(p => {
      const imageUrl = imagePath(p.nome);
      
      const card = document.createElement('div');
      card.className = 'card';
      
      // Only allow rating if episode is out
      if (p.ja_saiu) {
        card.addEventListener('click', () => {
          showRatingPopup(p);
        });
      } else {
        // Add visual indicator that rating is disabled
        card.style.cursor = 'not-allowed';
        card.addEventListener('click', () => {
          Swal.fire({
            title: 'Ainda n√£o saiu',
            text: `O epis√≥dio de "${p.nome}" ainda n√£o saiu esta semana.`,
            icon: 'info',
            timer: 3000,
            showConfirmButton: false
          });
        });
      }

      const front = document.createElement('div');
      front.className = 'card-front' + (p.ja_saiu ? '' : ' front-inactive');
      front.style.backgroundImage = `url(${imageUrl})`;
      front.style.backgroundColor = '#333'; // Fallback background color

      const overlay = document.createElement('div');
      overlay.className = 'overlay';
      
      // Only show ratings that have been given
      let ratingsHtml = '';
      if (p.ratingPedro) {
        ratingsHtml += `<div>Pedro: ${p.ratingPedro}/10</div>`;
      }
      if (p.ratingJoao) {
        ratingsHtml += `<div>Jo√£o: ${p.ratingJoao}/10</div>`;
      }
      
      overlay.innerHTML = `
        <button onclick="openHistory('${p.id}', '${p.nome}')" 
                style="position: absolute; top: 10px; right: 10px; 
                       background: rgba(0,0,0,0.8); color: white; border: 1px solid #fff; 
                       padding: 6px 12px; border-radius: 15px; font-size: 11px; cursor: pointer;
                       transition: all 0.3s; z-index: 10;">
          Hist√≥rico
        </button>
        <div style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; opacity: 0; transition: opacity 0.3s;" class="hover-content">
          <h3>${p.nome}</h3>
          <div style="margin-top: 10px; font-size: 14px;">
            ${ratingsHtml}
          </div>
        </div>
      `;
      front.appendChild(overlay);
      card.appendChild(front);
      grid.appendChild(card);
    });
  } catch (error) {
    console.error('Error rendering podcasts:', error);
    const grid = document.getElementById('podcasts');
    if (grid) {
      grid.innerHTML = `<p>Erro ao carregar podcasts: ${error.message}</p>`;
    }
  }
}

// Fluxo inicial
(async () => {
  try {
    // Pedir permiss√£o para notifica√ß√µes
    if ('Notification' in window) {
      const permission = await Notification.requestPermission();
      console.log('Notification permission:', permission);
    }
    
    if (!currentUser) {
      await askUser();
    } else {
      // Se j√° h√° utilizador, conectar WebSocket
      connectWebSocket();
    }
    await renderPodcasts();
  } catch (error) {
    console.error('Error in app initialization:', error);
    alert('Erro ao inicializar aplica√ß√£o: ' + error.message);
  }
})();

// Registrar Service Worker
if ('serviceWorker' in navigator) {
  window.addEventListener('load', async () => {
    try {
      const registration = await navigator.serviceWorker.register('/sw.js');
      console.log('Service Worker registado com sucesso:', registration);
      
      // Verificar se h√° atualiza√ß√µes
      registration.addEventListener('updatefound', () => {
        const newWorker = registration.installing;
        newWorker.addEventListener('statechange', () => {
          if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
            // Nova vers√£o dispon√≠vel
            console.log('Nova vers√£o do Service Worker dispon√≠vel!');
            // Opcional: mostrar notifica√ß√£o para o utilizador
          }
        });
      });
    } catch (error) {
      console.error('Erro ao registar Service Worker:', error);
    }
  });
}

// Pedir permiss√£o para notifica√ß√µes push
async function requestNotificationPermission() {
  if ('Notification' in window) {
    const permission = await Notification.requestPermission();
    console.log('Permiss√£o de notifica√ß√£o:', permission);
    
    if (permission === 'granted') {
      console.log('Notifica√ß√µes permitidas!');
      await subscribeToPushNotifications();
    }
  }
}

// Subscrever para push notifications
async function subscribeToPushNotifications() {
  if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
    console.log('Push messaging n√£o √© suportado');
    return;
  }

  try {
    // Obter VAPID public key
    const response = await fetch('/api/vapid-key');
    const { publicKey } = await response.json();
    
    // Converter para Uint8Array
    const applicationServerKey = urlBase64ToUint8Array(publicKey);
    
    // Subscrever
    const registration = await navigator.serviceWorker.ready;
    const subscription = await registration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: applicationServerKey
    });
    
    // Enviar subscription para o servidor
    await fetch('/api/subscribe', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        user: currentUser,
        subscription: subscription
      })
    });
    
    console.log('Push subscription successful!');
  } catch (error) {
    console.error('Error subscribing to push notifications:', error);
  }
}

// Converter VAPID key
function urlBase64ToUint8Array(base64String) {
  const padding = '='.repeat((4 - base64String.length % 4) % 4);
  const base64 = (base64String + padding)
    .replace(/-/g, '+')
    .replace(/_/g, '/');

  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);

  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}

// Fun√ß√£o para abrir hist√≥rico
function openHistory(podcastId, podcastName) {
  window.open(`/historico.html?id=${podcastId}&nome=${encodeURIComponent(podcastName)}`, '_blank');
}

// Chamar quando a app carrega
requestNotificationPermission();
</script>

</body>
</html>
