import express from "express";
import Database from "better-sqlite3";
import path from "path";
import fs from "fs";
import fetch from "node-fetch";
import { parseStringPromise } from "xml2js";
import { WebSocketServer } from "ws";
import { createServer } from "http";
import multer from "multer";
import webpush from "web-push";

const __dirname = path.resolve();
const app = express();
const PORT = 3000;

// Criar servidor HTTP
const server = createServer(app);

// Criar servidor WebSocket
const wss = new WebSocketServer({ server });

// Armazenar conex√µes WebSocket por utilizador
const userConnections = new Map();

// Armazenar subscriptions para push notifications
const pushSubscriptions = new Map();

// Configurar web-push (VAPID keys) - DESABILITADO TEMPORARIAMENTE
const vapidKeys = {
  publicKey: 'BKKVK_6hgl_ouZokyTiZs6OcPn3FGXYU_fL05gDrhDMRyHUx4oN8iORcD_zr3i0bkcQK5r4t2Sh-vpeqXVcXN8A',
  privateKey: 'SwKMkc7Hn0KMsbmxJZjoJZNFD1lzKncuFqN6knFRdt0'
};

webpush.setVapidDetails(
  'mailto:podcastbattle@example.com',
  vapidKeys.publicKey,
  vapidKeys.privateKey
);

// Configurar multer para upload de imagens
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const imgDir = path.join(__dirname, 'public', 'img');
    if (!fs.existsSync(imgDir)) {
      fs.mkdirSync(imgDir, { recursive: true });
    }
    cb(null, imgDir);
  },
  filename: (req, file, cb) => {
    // Usar o nome do podcast + extens√£o original
    const podcastName = req.body.nome || 'podcast';
    const cleanName = podcastName
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, '')
      .replace(/\s+/g, '_');
    const ext = path.extname(file.originalname);
    cb(null, `${cleanName}${ext}`);
  }
});

const upload = multer({ 
  storage: storage,
  fileFilter: (req, file, cb) => {
    // Aceitar apenas imagens
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Apenas ficheiros de imagem s√£o permitidos!'), false);
    }
  },
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB max
  }
});

// --- Serve static ---
app.use(express.static(path.join(__dirname, 'public')));

// --- DB setup ---
if (!fs.existsSync(path.join(__dirname, "data"))) fs.mkdirSync(path.join(__dirname, "data"));
const db = new Database(path.join(__dirname, "data", "podcast_battle.db"));

// --- WebSocket handling ---
wss.on('connection', (ws, req) => {
  console.log('Nova conex√£o WebSocket estabelecida');
  
  ws.on('message', (data) => {
    try {
      const message = JSON.parse(data.toString());
      
      if (message.type === 'register') {
        // Regista o utilizador
        const { user } = message;
        userConnections.set(user, ws);
        console.log(`Utilizador ${user} registado para notifica√ß√µes`);
        
        // Enviar confirma√ß√£o
        ws.send(JSON.stringify({
          type: 'registered',
          user: user
        }));
      }
    } catch (error) {
      console.error('Erro ao processar mensagem WebSocket:', error);
    }
  });
  
  ws.on('close', () => {
    // Remove a conex√£o quando o utilizador se desconecta
    for (const [user, connection] of userConnections.entries()) {
      if (connection === ws) {
        userConnections.delete(user);
        console.log(`Utilizador ${user} desconectado`);
        break;
      }
    }
  });
});

// Fun√ß√£o para enviar notifica√ß√£o para um utilizador espec√≠fico
function sendNotificationToUser(targetUser, notification) {
  console.log(`üì§ Enviando notifica√ß√£o para ${targetUser}:`, notification);
  
  const connection = userConnections.get(targetUser);
  if (connection && connection.readyState === 1) { // WebSocket.OPEN
    const messageToSend = {
      type: 'notification',
      ...notification
    };
    
    console.log(`üì§ Mensagem WebSocket a enviar:`, messageToSend);
    
    connection.send(JSON.stringify(messageToSend));
    console.log(`‚úÖ Notifica√ß√£o enviada para ${targetUser}`);
    return true;
  } else {
    console.log(`‚ùå Utilizador ${targetUser} n√£o est√° conectado`);
    return false;
  }
}

// --- Create tables ---
db.exec(`
CREATE TABLE IF NOT EXISTS podcasts (
  id TEXT PRIMARY KEY,
  nome TEXT NOT NULL,
  link TEXT NOT NULL,
  dia_da_semana TEXT NOT NULL,
  imagem TEXT,
  plataforma TEXT,
  rss TEXT,[]
  channelId TEXT
);
`);

db.exec(`
CREATE TABLE IF NOT EXISTS episodios (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  podcast_id TEXT NOT NULL,
  numero TEXT NOT NULL,
  titulo TEXT NOT NULL,
  data_publicacao TEXT NOT NULL,
  FOREIGN KEY(podcast_id) REFERENCES podcasts(id)
);
`);

// Migrar coluna numero de INTEGER para TEXT para suportar n√∫meros decimais
try {
  db.exec(`ALTER TABLE episodios ADD COLUMN numero_temp INTEGER`);
  db.exec(`UPDATE episodios SET numero_temp = CAST(numero AS INTEGER)`);
  db.exec(`ALTER TABLE episodios DROP COLUMN numero`);
  db.exec(`ALTER TABLE episodios RENAME COLUMN numero_temp TO numero`);
  console.log('‚úÖ Coluna numero migrada para INTEGER (sem decimais)');
} catch (error) {
  console.log('‚ÑπÔ∏è Migra√ß√£o da coluna numero j√° foi feita ou n√£o √© necess√°ria');
}

// Criar tabela ratings com estrutura antiga primeiro
db.exec(`
CREATE TABLE IF NOT EXISTS ratings (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  podcast_id TEXT NOT NULL,
  user TEXT NOT NULL,
  rating INTEGER NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY(podcast_id) REFERENCES podcasts(id),
  UNIQUE(podcast_id, user)
);
`);

// Migrar para nova estrutura com episode_id
try {
  // Verificar se a coluna episode_id j√° existe
  const columns = db.prepare("PRAGMA table_info(ratings)").all();
  const hasEpisodeId = columns.some(col => col.name === 'episode_id');
  
  if (!hasEpisodeId) {
    console.log('üîÑ Migrando tabela ratings para nova estrutura...');
    
    // Criar nova tabela com estrutura correta
    db.exec(`
      CREATE TABLE ratings_new (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        podcast_id TEXT NOT NULL,
        episode_id INTEGER NOT NULL,
        user TEXT NOT NULL,
        rating INTEGER NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY(podcast_id) REFERENCES podcasts(id),
        FOREIGN KEY(episode_id) REFERENCES episodios(id),
        UNIQUE(podcast_id, episode_id, user)
      );
    `);
    
    // Migrar dados existentes (se houver)
    const existingRatings = db.prepare("SELECT * FROM ratings").all();
    if (existingRatings.length > 0) {
      console.log(`üì¶ Encontrados ${existingRatings.length} ratings para migrar...`);
      
      for (const rating of existingRatings) {
        // Buscar o epis√≥dio mais recente do podcast
        const latestEpisode = db.prepare(`
          SELECT id FROM episodios 
          WHERE podcast_id = ? 
          ORDER BY numero DESC 
          LIMIT 1
        `).get(rating.podcast_id);
        
        if (latestEpisode) {
          db.prepare(`
            INSERT INTO ratings_new (podcast_id, episode_id, user, rating, created_at)
            VALUES (?, ?, ?, ?, ?)
          `).run(rating.podcast_id, latestEpisode.id, rating.user, rating.rating, rating.created_at);
        }
      }
    }
    
    // Remover tabela antiga e renomear nova
    db.exec("DROP TABLE ratings");
    db.exec("ALTER TABLE ratings_new RENAME TO ratings");
    
    console.log('‚úÖ Migra√ß√£o conclu√≠da!');
  }
} catch (error) {
  console.error('Erro na migra√ß√£o:', error);
}

// --- Default podcasts ---
const defaultPodcasts = [
  { nome: "watch.tm", link: "https://anchor.fm/s/df67421c/podcast/rss", dia: "domingo", img: "/img/watch.tm.png", plataforma:"spotify", rss:"https://anchor.fm/s/df67421c/podcast/rss" },
  { nome: "√† noite mata", link: "https://open.spotify.com/show/0PL5pILKjANwZ8UK9KtbqF?si=dda4315119f642fe", dia: "segunda", img: "/img/NoiteMata.png", plataforma:"spotify", rss:"https://anchor.fm/s/db97b450/podcast/rss" },
  { nome: "desnorte", link: "https://open.spotify.com/show/1FuehRKqgMbl7d8KDUoSEa?si=aeea5574e45744cb", dia: "segunda", img: "/img/Desnorte.png", plataforma:"soundcloud", rss:"https://feeds.soundcloud.com/users/soundcloud:users:795862234/sounds.rss" },
  { nome: "Z√© Carioca", link: "https://podcasters.spotify.com/pod/show/ze-carioca", dia: "segunda", img: "/img/ZeCarioca.png", plataforma:"spotify", rss:"https://anchor.fm/s/ea5b58fc/podcast/rss" },
  { nome: "Cubinho", link: "https://open.spotify.com/show/2JLsy53hzl94Wn1GxqTzoD?si=d2701cbd233a4e1a", dia: "ter√ßa", img: "/img/Cubinho.png", plataforma:"spotify", rss:"https://anchor.fm/s/8e11a8d0/podcast/rss" },
  { nome: "Prata da Casa", link: "https://anchor.fm/s/1056d2710/podcast/rss", dia: "quarta", img: "/img/PrataDaCasa.png", plataforma:"spotify", rss:"https://anchor.fm/s/1056d2710/podcast/rss" },
  { nome: "Contraluz", link: "https://open.spotify.com/show/1iZVOcN0N79eR83v6g0UC9?si=3378ba9f5b0849db", dia: "s√°bado", img: "/img/Contraluz.png", plataforma:"spotify", rss:"https://anchor.fm/s/fb86963c/podcast/rss" },
  { nome: "Trocadilho", link: "https://open.spotify.com/show/7L4zV1ZWetD7aEyfaMZB10?si=31ea176718944bf4", dia: "s√°bado", img: "/img/Trocadilho.png", plataforma:"spotify", rss:"https://anchor.fm/s/3d61c0b4/podcast/rss" },
];

// --- Insert default podcasts if not exist ---
const insertPodcast = db.prepare(`
  INSERT OR IGNORE INTO podcasts (id,nome,link,dia_da_semana,imagem,plataforma,rss,channelId)
  VALUES (@id,@nome,@link,@dia_da_semana,@imagem,@plataforma,@rss,@channelId)
`);
for (const p of defaultPodcasts) {
  insertPodcast.run({
    id: Buffer.from(p.nome).toString('base64url').slice(0,20),
    nome: p.nome,
    link: p.link,
    dia_da_semana: p.dia,
    imagem: p.img,
    plataforma: p.plataforma,
    rss: p.rss || null,
    channelId: p.channelId || null
  });
}

// --- Helper: week order ---
const weekOrder = ["domingo","segunda","ter√ßa","quarta","quinta","sexta","s√°bado"];

// Helper function to get the start of the current week (Sunday)
function getWeekStart(date) {
  const d = new Date(date);
  const day = d.getDay();
  const diff = d.getDate() - day; // Subtract days to get to Sunday
  const weekStart = new Date(d.setDate(diff));
  weekStart.setHours(0, 0, 0, 0);
  return weekStart;
}

// Helper function to get the start of the week for a specific podcast day
function getWeekStartForPodcast(date, podcastDay) {
  const d = new Date(date);
  const currentDay = d.getDay();
  const podcastDayIndex = weekOrder.indexOf(podcastDay);
  
  // Calculate days to subtract to get to the podcast's day this week
  let daysToSubtract = currentDay - podcastDayIndex;
  if (daysToSubtract < 0) {
    daysToSubtract += 7; // If podcast day hasn't happened this week, go to next week
  }
  
  // Get the start of the current week (Sunday)
  const weekStart = getWeekStart(d);
  
  // Add days to get to the podcast's day this week
  const podcastWeekStart = new Date(weekStart);
  podcastWeekStart.setDate(weekStart.getDate() + podcastDayIndex);
  podcastWeekStart.setHours(0, 0, 0, 0);
  
  return podcastWeekStart;
}

// --- Fun√ß√µes para carregar de ficheiros ---
async function loadWatchTmFromFile(podcastId) {
  try {
    console.log('üìÅ Carregando watch.tm do ficheiro...');
    const fs = await import('fs');
    const fileContent = fs.readFileSync('./data/watchtm.txt', 'utf8');
    
    // Parse the file content (assuming it's similar to velhoamigo.txt format)
    const episodes = parseRssFromString(fileContent);
    
    console.log(`üìÖ Encontrados ${episodes.length} epis√≥dios no ficheiro`);
    
    // Insert episodes into database
    for (const episode of episodes) {
      try {
        db.prepare(`
          INSERT INTO episodios (podcast_id, numero, titulo, data_publicacao, link)
          VALUES (?, ?, ?, ?, ?)
        `).run(podcastId, episode.episodeNum, episode.title, episode.pubDate.toISOString(), episode.link || '');
      } catch (err) {
        console.log(`   ‚ö†Ô∏è Erro ao inserir epis√≥dio ${episode.episodeNum}: ${err.message}`);
      }
    }
    
    console.log(`‚úÖ watch.tm carregado: ${episodes.length} epis√≥dios`);
  } catch (error) {
    console.error('‚ùå Erro ao carregar watch.tm do ficheiro:', error);
  }
}

async function loadPrataDaCasaFromFile(podcastId) {
  try {
    console.log('üìÅ Carregando Prata da Casa do ficheiro...');
    const fs = await import('fs');
    const fileContent = fs.readFileSync('./data/pratadacasa.txt', 'utf8');
    
    // Parse the file content (assuming it's similar to velhoamigo.txt format)
    const episodes = parseRssFromString(fileContent);
    
    console.log(`üìÖ Encontrados ${episodes.length} epis√≥dios no ficheiro`);
    
    // Insert episodes into database
    for (const episode of episodes) {
      try {
        db.prepare(`
          INSERT INTO episodios (podcast_id, numero, titulo, data_publicacao, link)
          VALUES (?, ?, ?, ?, ?)
        `).run(podcastId, episode.episodeNum, episode.title, episode.pubDate.toISOString(), episode.link || '');
      } catch (err) {
        console.log(`   ‚ö†Ô∏è Erro ao inserir epis√≥dio ${episode.episodeNum}: ${err.message}`);
      }
    }
    
    console.log(`‚úÖ Prata da Casa carregado: ${episodes.length} epis√≥dios`);
  } catch (error) {
    console.error('‚ùå Erro ao carregar Prata da Casa do ficheiro:', error);
  }
}

// --- Fun√ß√µes de RSS/YouTube ---
async function getLastEpisode(podcastId) {
  const row = db.prepare(`SELECT numero, data_publicacao FROM episodios WHERE podcast_id = ? ORDER BY numero DESC LIMIT 1`).get(podcastId);
  return row || { numero: 0, data_publicacao: null };
}

async function checkRssPodcast(podcast) {
  try {
    const res = await fetch(podcast.rss);
    if (!res.ok) throw new Error(`Erro ao buscar RSS: ${res.status}`);
    const xml = await res.text();
    const data = await parseStringPromise(xml);
    const items = data.rss.channel[0].item;
    if (!items || items.length === 0) return null;
    const latest = items[0];
    const title = latest.title[0];
    const pubDate = new Date(latest.pubDate[0]);
    const match = title.match(/(\d{1,4})/);
    const episodeNum = match ? parseInt(match[1],10) : null;
    return { episodeNum, title, pubDate };
  } catch(err) { console.error(`Erro RSS podcast ${podcast.nome}:`, err); return null; }
}

async function checkYoutubePodcast(podcast) {
  try {
    const rssUrl = `https://www.youtube.com/feeds/videos.xml?channel_id=${podcast.channelId}`;
    const res = await fetch(rssUrl);
    if (!res.ok) throw new Error(`Erro ao buscar RSS YouTube: ${res.status}`);
    const xml = await res.text();
    const data = await parseStringPromise(xml);
    const entries = data.feed.entry;
    if (!entries || entries.length === 0) return null;
    const latest = entries[0];
    const title = latest['title'][0];
    const pubDate = new Date(latest['published'][0]);
    const match = title.match(/(\d{1,4})/);
    const episodeNum = match ? parseInt(match[1],10) : null;
    return { episodeNum, title, pubDate };
  } catch(err) { console.error(`Erro YouTube podcast ${podcast.nome}:`, err); return null; }
}

async function updatePodcasts() {
  const podcasts = db.prepare(`SELECT * FROM podcasts`).all();
  const today = new Date();
  const currentWeekStart = getWeekStart(today);
  
  for(const podcast of podcasts){
    const lastEp = await getLastEpisode(podcast.id);
    
    // Skip if we already have an episode from this week
    if (lastEp && lastEp.data_publicacao) {
      const episodeDate = new Date(lastEp.data_publicacao);
      if (episodeDate >= currentWeekStart) {
        console.log(`‚è≠Ô∏è  ${podcast.nome}: J√° tem epis√≥dio desta semana (Ep ${lastEp.numero})`);
        continue;
      }
    }
    
    console.log(`üîç Verificando ${podcast.nome}...`);
    let latest = null;
    if(podcast.plataforma==="spotify" || podcast.plataforma==="soundcloud"){
      latest = await checkRssPodcast(podcast);
    } else if(podcast.plataforma==="youtube"){
      latest = await checkYoutubePodcast(podcast);
    }
    if(!latest) continue;
    if(latest.episodeNum && latest.episodeNum>lastEp.numero){
      console.log(`‚úÖ Novo epis√≥dio para ${podcast.nome}: Ep ${latest.episodeNum}`);
      db.prepare(`INSERT INTO episodios (podcast_id,numero,titulo,data_publicacao) VALUES (?,?,?,?)`)
        .run(podcast.id, latest.episodeNum, latest.title, latest.pubDate.toISOString());
    }
  }
}

// Fun√ß√£o para preencher todos os hist√≥ricos dos podcasts
async function fillAllPodcastHistories() {
  console.log('üöÄ Iniciando preenchimento de todos os hist√≥ricos...');
  const podcasts = db.prepare(`SELECT * FROM podcasts`).all();
  
  for(const podcast of podcasts){
    console.log(`\nüìö Preenchendo hist√≥rico de ${podcast.nome}...`);
    
    try {
      let episodes = [];
      
      if(podcast.plataforma === "spotify" || podcast.plataforma === "soundcloud"){
        episodes = await getAllRssEpisodes(podcast);
      } else if(podcast.plataforma === "youtube"){
        episodes = await getAllYoutubeEpisodes(podcast);
      }
      
      if(episodes && episodes.length > 0){
        console.log(`   üì• Encontrados ${episodes.length} epis√≥dios para ${podcast.nome}`);
        
        // Inserir epis√≥dios na base de dados (ignorar duplicados)
        const insertEpisode = db.prepare(`
          INSERT OR IGNORE INTO episodios (podcast_id, numero, titulo, data_publicacao) 
          VALUES (?, ?, ?, ?)
        `);
        
        let addedCount = 0;
        for(const episode of episodes){
          const result = insertEpisode.run(
            podcast.id, 
            episode.episodeNum, 
            episode.title, 
            episode.pubDate.toISOString()
          );
          if(result.changes > 0) addedCount++;
        }
        
        console.log(`   ‚úÖ Adicionados ${addedCount} novos epis√≥dios para ${podcast.nome}`);
      } else {
        console.log(`   ‚ö†Ô∏è  Nenhum epis√≥dio encontrado para ${podcast.nome}`);
      }
      
    } catch(error) {
      console.error(`   ‚ùå Erro ao preencher ${podcast.nome}:`, error.message);
    }
  }
  
  console.log('\nüéâ Preenchimento de hist√≥ricos conclu√≠do!');
}

// Fun√ß√£o para preencher hist√≥rico de um podcast espec√≠fico
async function fillPodcastHistory(podcast) {
  console.log(`\nüìö Preenchendo hist√≥rico de ${podcast.nome}...`);
  
  try {
    let episodes = [];
    
    if(podcast.plataforma === "spotify" || podcast.plataforma === "soundcloud"){
      episodes = await getAllRssEpisodes(podcast);
    } else if(podcast.plataforma === "youtube"){
      episodes = await getAllYoutubeEpisodes(podcast);
    }
    
    if(episodes && episodes.length > 0){
      console.log(`   üì• Encontrados ${episodes.length} epis√≥dios para ${podcast.nome}`);
      
      // Inserir epis√≥dios na base de dados (ignorar duplicados)
      const insertEpisode = db.prepare(`
        INSERT OR IGNORE INTO episodios (podcast_id, numero, titulo, data_publicacao) 
        VALUES (?, ?, ?, ?)
      `);
      
      let addedCount = 0;
      for(const episode of episodes){
        const result = insertEpisode.run(
          podcast.id, 
          episode.episodeNum, 
          episode.title, 
          episode.pubDate.toISOString()
        );
        if(result.changes > 0) addedCount++;
      }
      
      console.log(`   ‚úÖ Adicionados ${addedCount} novos epis√≥dios para ${podcast.nome}`);
      return { success: true, addedCount, totalFound: episodes.length };
    } else {
      console.log(`   ‚ö†Ô∏è  Nenhum epis√≥dio encontrado para ${podcast.nome}`);
      return { success: true, addedCount: 0, totalFound: 0 };
    }
    
  } catch(error) {
    console.error(`   ‚ùå Erro ao preencher ${podcast.nome}:`, error.message);
    return { success: false, error: error.message };
  }
}

// Fun√ß√£o para buscar todos os epis√≥dios de um podcast RSS
async function getAllRssEpisodes(podcast) {
  try {
    const res = await fetch(podcast.rss);
    if (!res.ok) throw new Error(`Erro ao buscar RSS: ${res.status}`);
    const xml = await res.text();
    const data = await parseStringPromise(xml);
    const items = data.rss.channel[0].item;
    
    if (!items || items.length === 0) return [];
    
    // Parsing espec√≠fico para Z√© Carioca
    if (podcast.nome === 'Z√© Carioca') {
      return getAllZeCariocaRssEpisodes(items);
    }

    // Parsing espec√≠fico para Prata da Casa
    if (podcast.nome === 'Prata da Casa') {
      return getAllPrataDaCasaRssEpisodes(items);
    }

    // Parsing espec√≠fico para Velho amigo
    if (podcast.nome === 'Velho amigo') {
      return getAllVelhoAmigoRssEpisodes(items);
    }
    
    // Parsing gen√©rico para outros podcasts RSS
    const episodes = items.map((item, index) => {
      const title = item.title[0];
      const pubDate = new Date(item.pubDate[0]);
      
      // Tentar extrair n√∫mero do t√≠tulo, sen√£o usar posi√ß√£o no RSS
      const match = title.match(/(\d{1,4})/);
      const episodeNum = match ? parseInt(match[1], 10) : (items.length - index);
      
      return { episodeNum, title, pubDate };
    });
    
    // Ordenar por n√∫mero do epis√≥dio (crescente)
    return episodes.sort((a, b) => a.episodeNum - b.episodeNum);
    
  } catch(err) { 
    console.error(`Erro RSS podcast ${podcast.nome}:`, err); 
    return []; 
  }
}

// Fun√ß√£o espec√≠fica para parsing do watch.tm via RSS
async function getAllWatchTmRssEpisodes(items) {
  console.log('üé¨ Parsing espec√≠fico para watch.tm RSS...');
  
  const episodes = [];
  
  for (const item of items) {
    const title = item.title[0];
    const pubDate = new Date(item.pubDate[0]);
    
    // Verificar se o t√≠tulo segue o formato: "t√≠tulo | #n√∫mero"
    const watchTmPattern = /^(.+?)\s*\|\s*#(\d{1,4})$/i;
    const match = title.match(watchTmPattern);
    
    if (match) {
      const episodeTitle = match[1].trim();
      const episodeNum = parseInt(match[2], 10);
      
      episodes.push({
        episodeNum,
        title: episodeTitle,
        pubDate
      });
      
      console.log(`   ‚úÖ Epis√≥dio v√°lido: #${episodeNum} - ${episodeTitle}`);
    } else {
      console.log(`   ‚ùå Epis√≥dio ignorado (formato inv√°lido): "${title}"`);
    }
  }
  
  // Ordenar por n√∫mero do epis√≥dio (crescente)
  const sortedEpisodes = episodes.sort((a, b) => a.episodeNum - b.episodeNum);
  
  console.log(`üé¨ Total de epis√≥dios watch.tm v√°lidos: ${sortedEpisodes.length}`);
  return sortedEpisodes;
}

// Fun√ß√£o espec√≠fica para parsing do Z√© Carioca via RSS
async function getAllZeCariocaRssEpisodes(items) {
  console.log('üé≠ Parsing espec√≠fico para Z√© Carioca RSS...');
  
  const episodes = [];
  
  for (const item of items) {
    const title = item.title[0];
    const pubDate = new Date(item.pubDate[0]);
    
    // Verificar se o t√≠tulo segue o formato: "n√∫mero : t√≠tulo"
    const zeCariocaPattern = /^(\d{1,4})\s*:\s*(.+)$/i;
    const match = title.match(zeCariocaPattern);
    
    if (match) {
      const episodeNum = parseInt(match[1], 10);
      const episodeTitle = match[2].trim();
      
      episodes.push({
        episodeNum,
        title: episodeTitle,
        pubDate
      });
      
      console.log(`   ‚úÖ Epis√≥dio v√°lido: #${episodeNum} - ${episodeTitle}`);
    } else {
      console.log(`   ‚ùå Epis√≥dio ignorado (formato inv√°lido): "${title}"`);
    }
  }
  
  // Ordenar por n√∫mero do epis√≥dio (crescente)
  const sortedEpisodes = episodes.sort((a, b) => a.episodeNum - b.episodeNum);
  
  console.log(`üé≠ Total de epis√≥dios Z√© Carioca v√°lidos: ${sortedEpisodes.length}`);
  return sortedEpisodes;
}

// Fun√ß√£o espec√≠fica para parsing do Prata da Casa via RSS
async function getAllPrataDaCasaRssEpisodes(items) {
  console.log('üíé Parsing espec√≠fico para Prata da Casa RSS...');
  
  const episodes = [];
  
  for (const item of items) {
    const title = item.title[0];
    const pubDate = new Date(item.pubDate[0]);
    
    // Verificar se o t√≠tulo segue o formato: "Prata da Casa #XX - T√≠tulo"
    const prataDaCasaPattern = /^Prata da Casa #(\d{1,4})\s*-\s*(.+)$/i;
    const match = title.match(prataDaCasaPattern);
    
    if (match) {
      const episodeNum = parseInt(match[1], 10);
      const episodeTitle = match[2].trim();
      
      episodes.push({
        episodeNum,
        title: episodeTitle,
        pubDate
      });
      
      console.log(`   ‚úÖ Epis√≥dio v√°lido: #${episodeNum} - ${episodeTitle}`);
    } else {
      console.log(`   ‚ùå Epis√≥dio ignorado (formato inv√°lido): "${title}"`);
    }
  }
  
  // Ordenar por n√∫mero do epis√≥dio (crescente)
  const sortedEpisodes = episodes.sort((a, b) => a.episodeNum - b.episodeNum);
  console.log(`üíé Total de epis√≥dios Prata da Casa v√°lidos: ${sortedEpisodes.length}`);
  return sortedEpisodes;
}

// Fun√ß√£o espec√≠fica para parsing do Velho amigo via RSS
function getAllVelhoAmigoRssEpisodes(items) {
  console.log('üë¥ Parsing espec√≠fico para Velho amigo RSS...');
  
  const episodes = [];
  
  for (const item of items) {
    const title = item.title[0];
    const pubDate = new Date(item.pubDate[0]);
    
    // Para Velho amigo, procurar por #n√∫mero no final do t√≠tulo
    // Aceitar n√∫meros decimais como 0.1, 0.3, 0.95, etc.
    // Formato: "t√≠tulo | #n√∫mero" (incluindo 0.95, 0.9, etc.)
    const match = title.match(/\|\s*#(\d+(?:\.\d+)?)$/);
    if (match) {
      const numberStr = match[1];
      let episodeNum;
      
      // Se for um n√∫mero decimal (0.1, 0.3, etc.), manter como string
      if (numberStr.includes('.')) {
        episodeNum = numberStr; // Manter como "0.95" em vez de "95"
      } else {
        // Para n√∫meros inteiros, manter como inteiro (n√£o converter para float)
        episodeNum = parseInt(numberStr, 10);
      }
      
      // MANTER o t√≠tulo exatamente como vem do ficheiro (n√£o limpar)
      episodes.push({
        episodeNum,
        title: title, // T√≠tulo original sem modifica√ß√µes
        pubDate
      });
      
      console.log(`   ‚úÖ Epis√≥dio v√°lido: #${episodeNum} - ${title.substring(0, 50)}...`);
    } else {
      // Debug: mostrar t√≠tulos que n√£o fazem match
      if (title.includes('amizade') || title.includes('0.95')) {
        console.log(`   üîç DEBUG - T√≠tulo sem match: "${title}"`);
      }
    }
  }
  
  // Ordenar por n√∫mero do epis√≥dio (crescente)
  const sortedEpisodes = episodes.sort((a, b) => {
    // Para n√∫meros decimais (strings), converter para float para compara√ß√£o
    // Para n√∫meros inteiros, usar diretamente
    const aNum = typeof a.episodeNum === 'string' ? parseFloat(a.episodeNum) : a.episodeNum;
    const bNum = typeof b.episodeNum === 'string' ? parseFloat(b.episodeNum) : b.episodeNum;
    return aNum - bNum;
  });
  
  console.log(`üë¥ Total de epis√≥dios Velho amigo v√°lidos: ${sortedEpisodes.length}`);
  return sortedEpisodes;
}

// Fun√ß√£o para buscar todos os epis√≥dios de um canal YouTube
async function getAllYoutubeEpisodes(podcast) {
  try {
    const rssUrl = `https://www.youtube.com/feeds/videos.xml?channel_id=${podcast.channelId}`;
    const res = await fetch(rssUrl);
    if (!res.ok) throw new Error(`Erro ao buscar RSS YouTube: ${res.status}`);
    const xml = await res.text();
    const data = await parseStringPromise(xml);
    const entries = data.feed.entry;
    
    if (!entries || entries.length === 0) return [];
    
    // Parsing espec√≠fico para watch.tm
    if (podcast.nome === 'watch.tm') {
      return getAllWatchTmEpisodes(entries);
    }
    
    // Parsing gen√©rico para outros podcasts YouTube
    const episodes = entries.map(entry => {
      const title = entry['title'][0];
      const pubDate = new Date(entry['published'][0]);
      const match = title.match(/(\d{1,4})/);
      const episodeNum = match ? parseInt(match[1], 10) : null;
      
      return { episodeNum, title, pubDate };
    }).filter(ep => ep.episodeNum !== null); // S√≥ epis√≥dios com n√∫mero v√°lido
    
    // Ordenar por n√∫mero do epis√≥dio (crescente)
    return episodes.sort((a, b) => a.episodeNum - b.episodeNum);
    
  } catch(err) { 
    console.error(`Erro YouTube podcast ${podcast.nome}:`, err); 
    return []; 
  }
}

// Fun√ß√£o espec√≠fica para parsing do watch.tm
async function getAllWatchTmEpisodes(entries) {
  console.log('üé¨ Parsing espec√≠fico para watch.tm...');
  
  const episodes = [];
  
  for (const entry of entries) {
    const title = entry['title'][0];
    const pubDate = new Date(entry['published'][0]);
    
    // Verificar se o t√≠tulo segue o formato: "t√≠tulo | watch.tm {n√∫mero}"
    const watchTmPattern = /^(.+?)\s*\|\s*watch\.tm\s+(\d{1,4})$/i;
    const match = title.match(watchTmPattern);
    
    if (match) {
      const episodeTitle = match[1].trim();
      const episodeNum = parseInt(match[2], 10);
      
      episodes.push({
        episodeNum,
        title: episodeTitle,
        pubDate
      });
      
      console.log(`   ‚úÖ Epis√≥dio v√°lido: #${episodeNum} - ${episodeTitle}`);
    } else {
      console.log(`   ‚ùå Epis√≥dio ignorado (formato inv√°lido): "${title}"`);
    }
  }
  
  // Ordenar por n√∫mero do epis√≥dio (crescente)
  const sortedEpisodes = episodes.sort((a, b) => a.episodeNum - b.episodeNum);
  
  console.log(`üé¨ Total de epis√≥dios watch.tm v√°lidos: ${sortedEpisodes.length}`);
  return sortedEpisodes;
}

// --- API: podcasts ---
app.get('/api/podcasts', async (req,res)=>{
  // Verificar epis√≥dios sempre que a p√°gina √© aberta
  console.log('üîÑ Verificando epis√≥dios...');
  await updatePodcasts();
  
  const rows = db.prepare(`SELECT * FROM podcasts`).all();
  const today = new Date();
  const weekDay = today.toLocaleDateString('pt-PT',{ weekday:'long' }).toLowerCase();

  const podcasts = rows.map(p=>{
    const lastEp = db.prepare(`SELECT numero, data_publicacao FROM episodios WHERE podcast_id = ? ORDER BY numero DESC LIMIT 1`).get(p.id);
    
    // Check if episode is from current week (since last Sunday)
    let ja_saiu;
    if (lastEp && lastEp.data_publicacao) {
      const episodeDate = new Date(lastEp.data_publicacao);
      const today = new Date();
      
      // Get the start of the current week (Sunday)
      const currentWeekStart = getWeekStart(today);
      
      console.log(`Podcast: ${p.nome}, Episode date: ${episodeDate.toISOString()}, Current week start: ${currentWeekStart.toISOString()}`);
      
      // Episode is out if it's from the current week (since last Sunday)
      ja_saiu = episodeDate >= currentWeekStart;
      console.log(`ja_saiu: ${ja_saiu} (episode >= current week start: ${episodeDate >= currentWeekStart})`);
    } else {
      // If no episode data, check if we're past the podcast's day this week
      ja_saiu = weekOrder.indexOf(weekDay) >= weekOrder.indexOf(p.dia_da_semana);
      console.log(`Podcast: ${p.nome}, No episode data, ja_saiu: ${ja_saiu} (current day: ${weekDay}, podcast day: ${p.dia_da_semana})`);
    }
    
    // Get ratings for Pedro and Jo√£o (do epis√≥dio mais recente)
    const latestEpisode = db.prepare(`SELECT id FROM episodios WHERE podcast_id = ? ORDER BY numero DESC LIMIT 1`).get(p.id);
    let ratingPedro = null;
    let ratingJoao = null;
    
    if (latestEpisode) {
      ratingPedro = db.prepare(`SELECT rating FROM ratings WHERE podcast_id = ? AND episode_id = ? AND user = 'Pedro'`).get(p.id, latestEpisode.id);
      ratingJoao = db.prepare(`SELECT rating FROM ratings WHERE podcast_id = ? AND episode_id = ? AND user = 'Jo√£o'`).get(p.id, latestEpisode.id);
    }
    
    return { 
      ...p, 
      ja_saiu,
      ratingPedro: ratingPedro ? ratingPedro.rating : 0,
      ratingJoao: ratingJoao ? ratingJoao.rating : 0
    };
  });

  podcasts.sort((a,b)=> weekOrder.indexOf(a.dia_da_semana)-weekOrder.indexOf(b.dia_da_semana));
  res.json({ podcasts });
});

// --- API: rate podcast ---
app.post('/api/rate', express.json(), (req,res)=>{
  console.log('Received rating request:', req.body);
  const { podcastId, episodeId, user, rating } = req.body;
  
  console.log('Parsed data:', { podcastId, episodeId, user, rating });
  console.log('Validation:', {
    hasPodcastId: !!podcastId,
    hasEpisodeId: !!episodeId,
    hasUser: !!user,
    hasRating: !!rating,
    ratingType: typeof rating,
    ratingValue: rating,
    isInRange: rating >= 1 && rating <= 10
  });
  
  if (!podcastId || !user || !rating || rating < 1 || rating > 10) {
    console.log('Validation failed, returning 400');
    return res.status(400).json({ error: 'Invalid rating data' });
  }
  
  try {
    let targetEpisodeId = episodeId;
    
    // Se n√£o foi fornecido episodeId, buscar o epis√≥dio mais recente do podcast
    if (!episodeId) {
      const latestEpisode = db.prepare(`
        SELECT id FROM episodios 
        WHERE podcast_id = ? 
        ORDER BY numero DESC 
        LIMIT 1
      `).get(podcastId);
      
      if (!latestEpisode) {
        return res.status(404).json({ error: 'No episode found for this podcast' });
      }
      
      targetEpisodeId = latestEpisode.id;
    } else {
      // Verificar se o episodeId existe e pertence ao podcast
      const episode = db.prepare(`
        SELECT id FROM episodios 
        WHERE id = ? AND podcast_id = ?
      `).get(episodeId, podcastId);
      
      if (!episode) {
        return res.status(404).json({ error: 'Episode not found or does not belong to this podcast' });
      }
    }
    
    const insertRating = db.prepare(`
      INSERT OR REPLACE INTO ratings (podcast_id, episode_id, user, rating) 
      VALUES (?, ?, ?, ?)
    `);
    insertRating.run(podcastId, targetEpisodeId, user, rating);
    console.log(`Rating saved successfully for episode ${targetEpisodeId}`);
    res.json({ success: true, episodeId: targetEpisodeId });
  } catch (error) {
    console.error('Error saving rating:', error);
    res.status(500).json({ error: 'Failed to save rating' });
  }
});

// --- API: clear rating ---
app.delete('/api/rate', express.json(), (req,res)=>{
  console.log('Received clear rating request:', req.body);
  const { podcastId, episodeId, user } = req.body;

  if (!podcastId || !user) {
    return res.status(400).json({ error: 'Missing podcastId or user' });
  }

  try {
    let targetEpisodeId = episodeId;
    
    // Se n√£o foi fornecido episodeId, buscar o epis√≥dio mais recente do podcast
    if (!episodeId) {
      const latestEpisode = db.prepare(`
        SELECT id FROM episodios 
        WHERE podcast_id = ? 
        ORDER BY numero DESC 
        LIMIT 1
      `).get(podcastId);
      
      if (!latestEpisode) {
        return res.status(404).json({ error: 'No episode found for this podcast' });
      }
      
      targetEpisodeId = latestEpisode.id;
    } else {
      // Verificar se o episodeId existe e pertence ao podcast
      const episode = db.prepare(`
        SELECT id FROM episodios 
        WHERE id = ? AND podcast_id = ?
      `).get(episodeId, podcastId);
      
      if (!episode) {
        return res.status(404).json({ error: 'Episode not found or does not belong to this podcast' });
      }
    }
    
    const deleteRating = db.prepare(`
      DELETE FROM ratings WHERE podcast_id = ? AND episode_id = ? AND user = ?
    `);
    const result = deleteRating.run(podcastId, targetEpisodeId, user);
    console.log('Rating cleared successfully');
    res.json({ success: true, deleted: result.changes > 0 });
  } catch (error) {
    console.error('Error clearing rating:', error);
    res.status(500).json({ error: 'Failed to clear rating' });
  }
});

// --- API: subscribe to push notifications ---
app.post('/api/subscribe', express.json(), (req, res) => {
  console.log('Received push subscription request:', req.body);
  const { user, subscription } = req.body;

  if (!user || !subscription) {
    return res.status(400).json({ error: 'Missing user or subscription data' });
  }

  try {
    // Guardar subscription
    pushSubscriptions.set(user, subscription);
    console.log(`Push subscription saved for user: ${user}`);
    
    res.json({ 
      success: true, 
      message: 'Push subscription saved successfully' 
    });
  } catch (error) {
    console.error('Error saving push subscription:', error);
    res.status(500).json({ error: 'Failed to save push subscription' });
  }
});

// --- API: get VAPID public key ---
app.get('/api/vapid-key', (req, res) => {
  res.json({ publicKey: vapidKeys.publicKey });
});

// --- API: get episodes for a podcast ---
app.get('/api/episodes/:podcastId', (req, res) => {
  const { podcastId } = req.params;
  
  if (!podcastId) {
    return res.status(400).json({ error: 'Missing podcastId' });
  }
  
  try {
    // Buscar epis√≥dios do podcast com ratings espec√≠ficos por epis√≥dio
    const episodes = db.prepare(`
      SELECT e.id, e.numero, e.titulo, e.data_publicacao,
             rp.rating as ratingPedro, rj.rating as ratingJoao
      FROM episodios e
      LEFT JOIN ratings rp ON e.id = rp.episode_id AND rp.user = 'Pedro'
      LEFT JOIN ratings rj ON e.id = rj.episode_id AND rj.user = 'Jo√£o'
      WHERE e.podcast_id = ?
      ORDER BY e.numero DESC
    `).all(podcastId);
    
    res.json({ episodes });
  } catch (error) {
    console.error('Error fetching episodes:', error);
    res.status(500).json({ error: 'Failed to fetch episodes' });
  }
});

// Endpoint para apagar um podcast espec√≠fico e todos os seus dados
app.delete('/api/podcast/:id', (req, res) => {
  const { id } = req.params;
  
  try {
    console.log(`üóëÔ∏è Apagando podcast ${id} e todos os dados associados...`);
    
    // Desativar foreign key checks temporariamente
    db.prepare(`PRAGMA foreign_keys = OFF`).run();
    
    // Primeiro apagar todos os ratings do podcast
    const deleteRatings = db.prepare('DELETE FROM ratings WHERE podcast_id = ?');
    const ratingsResult = deleteRatings.run(id);
    console.log(`üóëÔ∏è Apagados ${ratingsResult.changes} ratings`);
    
    // Depois apagar todos os epis√≥dios do podcast
    const deleteEpisodes = db.prepare('DELETE FROM episodios WHERE podcast_id = ?');
    const episodesResult = deleteEpisodes.run(id);
    console.log(`üóëÔ∏è Apagados ${episodesResult.changes} epis√≥dios`);
    
    // Por fim apagar o podcast
    const deletePodcast = db.prepare('DELETE FROM podcasts WHERE id = ?');
    const podcastResult = deletePodcast.run(id);
    console.log(`üóëÔ∏è Apagado ${podcastResult.changes} podcast`);
    
    // Reativar foreign key checks
    db.prepare(`PRAGMA foreign_keys = ON`).run();
    
    if (podcastResult.changes === 0) {
      return res.status(404).json({ error: 'Podcast n√£o encontrado' });
    }
    
    res.json({ 
      success: true, 
      message: 'Podcast, epis√≥dios e ratings apagados com sucesso',
      ratingsDeleted: ratingsResult.changes,
      episodesDeleted: episodesResult.changes,
      podcastDeleted: podcastResult.changes
    });
  } catch (error) {
    console.error('Erro ao apagar podcast:', error);
    res.status(500).json({ error: 'Erro ao apagar podcast' });
  }
});

// Endpoint para recriar o podcast Velho amigo e carregar epis√≥dios do RSS
app.get('/recreate-velho-amigo', async (req, res) => {
  try {
    console.log('üîÑ Recriando podcast Velho amigo e carregando epis√≥dios do RSS...');
    
    // Primeiro, criar o podcast se n√£o existir
    const podcastData = {
      nome: "Velho amigo",
      link: "https://anchor.fm/s/f05045d8/podcast/rss",
      dia: "quarta",
      img: "/img/VelhoAmigo.png",
      plataforma: "spotify",
      rss: "https://anchor.fm/s/f05045d8/podcast/rss"
    };
    
    // Verificar se j√° existe
    const existingPodcast = db.prepare(`SELECT * FROM podcasts WHERE nome = ?`).get(podcastData.nome);
    
    let podcastId;
    if (existingPodcast) {
      podcastId = existingPodcast.id;
      console.log(`‚úÖ Podcast ${podcastData.nome} j√° existe com ID: ${podcastId}`);
    } else {
      // Criar novo podcast
      const insertPodcast = db.prepare(`
        INSERT INTO podcasts (nome, link, dia_da_semana, img, plataforma, rss)
        VALUES (?, ?, ?, ?, ?, ?)
      `);
      
      const result = insertPodcast.run(
        podcastData.nome,
        podcastData.link,
        podcastData.dia,
        podcastData.img,
        podcastData.plataforma,
        podcastData.rss
      );
      
      podcastId = result.lastInsertRowid.toString();
      console.log(`‚úÖ Podcast ${podcastData.nome} criado com ID: ${podcastId}`);
    }
    
    // Desativar foreign key checks temporariamente
    db.prepare(`PRAGMA foreign_keys = OFF`).run();
    
    // Limpar epis√≥dios existentes
    const deleteResult = db.prepare(`DELETE FROM episodios WHERE podcast_id = ?`).run(podcastId);
    console.log(`üßπ Removidos ${deleteResult.changes} epis√≥dios antigos`);
    
    // Buscar epis√≥dios do RSS
    const episodes = await getAllRssEpisodes({ 
      id: podcastId, 
      nome: podcastData.nome, 
      rss: podcastData.rss,
      plataforma: podcastData.plataforma 
    });
    
    if (!episodes || episodes.length === 0) {
      db.prepare(`PRAGMA foreign_keys = ON`).run();
      return res.status(400).json({ error: 'Nenhum epis√≥dio encontrado no RSS' });
    }
    
    console.log(`üìä Total de epis√≥dios encontrados: ${episodes.length}`);
    
    // Inserir epis√≥dios na base de dados
    const insertEpisode = db.prepare(`
      INSERT OR IGNORE INTO episodios (podcast_id, numero, titulo, data_publicacao)
      VALUES (?, ?, ?, ?)
    `);
    
    let addedCount = 0;
    console.log(`üîÑ Inserindo ${episodes.length} epis√≥dios...`);
    
             for (let i = 0; i < episodes.length; i++) {
               const episode = episodes[i];
               console.log(`üìù Inserindo epis√≥dio ${i+1}/${episodes.length}: #${episode.episodeNum} - ${episode.title.substring(0, 50)}...`);
               
               // Debug: mostrar o tipo e valor do episodeNum
               console.log(`   üîç DEBUG - episodeNum: "${episode.episodeNum}" (tipo: ${typeof episode.episodeNum})`);
               
               try {
                 const result = insertEpisode.run(
                   podcastId,
                   episode.episodeNum,
                   episode.title,
                   episode.pubDate.toISOString()
                 );
                 if (result.changes > 0) addedCount++;
                 console.log(`   ‚úÖ Epis√≥dio #${episode.episodeNum} inserido com sucesso`);
               } catch (error) {
                 console.error(`   ‚ùå Erro ao inserir epis√≥dio #${episode.episodeNum}:`, error.message);
                 throw error;
               }
             }
    
    console.log(`‚úÖ Adicionados ${addedCount} novos epis√≥dios para ${podcastData.nome}`);
    
    // Reativar foreign key checks
    db.prepare(`PRAGMA foreign_keys = ON`).run();
    
    res.json({
      success: true,
      message: `${podcastData.nome} recriado e carregado do RSS! Adicionados ${addedCount} epis√≥dios`,
      podcastId: podcastId,
      episodesAdded: addedCount,
      totalFound: episodes.length,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Erro ao recriar Velho amigo:', error);
    res.status(500).json({
      error: 'Erro ao recriar Velho amigo',
      message: error.message
    });
  }
});

// --- API: send notification ---
app.post('/api/notify', express.json(), (req, res) => {
  console.log('Received notification request:', req.body);
  const { targetUser, podcastName, rating, message, fromUser, podcastId } = req.body;

  // Log individual fields for debugging
  console.log('Field validation:');
  console.log('  targetUser:', targetUser, typeof targetUser);
  console.log('  podcastName:', podcastName, typeof podcastName);
  console.log('  rating:', rating, typeof rating);
  console.log('  message:', message, typeof message);
  console.log('  fromUser:', fromUser, typeof fromUser);
  console.log('  podcastId:', podcastId, typeof podcastId);

  if (!targetUser || !podcastName || !rating || !message || !fromUser) {
    console.error('Missing required fields in notification request');
    return res.status(400).json({ error: 'Missing required fields' });
  }

  try {
    // Buscar n√∫mero do epis√≥dio mais recente
    let episodeNumber = '';
    let episodeNum = null;
    if (podcastId) {
      const lastEp = db.prepare(`SELECT numero FROM episodios WHERE podcast_id = ? ORDER BY numero DESC LIMIT 1`).get(podcastId);
      if (lastEp && lastEp.numero) {
        episodeNumber = ` - Ep ${lastEp.numero}`;
        episodeNum = lastEp.numero;
      }
    }

    // Enviar notifica√ß√£o via WebSocket
    console.log('üìù Criando objeto notification com:');
    console.log('  targetUser:', targetUser);
    console.log('  podcastName:', podcastName);
    console.log('  episodeNumber:', episodeNumber);
    console.log('  rating:', rating);
    console.log('  message:', message);
    console.log('  fromUser:', fromUser);
    console.log('  episodeNum:', episodeNum);
    console.log('  podcastId:', podcastId);
    
    const notification = {
      targetUser,
      podcastName: `${podcastName}${episodeNumber}`,
      rating,
      message,
      fromUser,
      episodeNumber: episodeNum,
      podcastId,
      timestamp: new Date().toISOString()
    };
    
    console.log('üìù Objeto notification criado:', notification);
    
    const sent = sendNotificationToUser(targetUser, notification);
    
    // Enviar notifica√ß√£o push se dispon√≠vel
    const pushSubscription = pushSubscriptions.get(targetUser);
    if (pushSubscription) {
      console.log(`Push subscription dispon√≠vel para ${targetUser}`);
      
      // Criar payload para push notification com t√≠tulo personalizado
      const pushPayload = {
        title: `üéß ${podcastName}${episodeNumber}`,
        body: `${fromUser} deu ${rating}/10: "${message}"`,
        icon: '/img/icon-192.svg',
        badge: '/img/badge-72.svg',
        data: {
          url: '/',
          podcastName,
          rating,
          message,
          fromUser,
          episodeNumber: episodeNum
        }
      };
      
      webpush.sendNotification(pushSubscription, JSON.stringify(pushPayload))
        .then(() => {
          console.log(`Push notification sent to ${targetUser}`);
        })
        .catch((error) => {
          console.error('Error sending push notification:', error);
          pushSubscriptions.delete(targetUser);
        });
    }
    
    console.log(`üì± NOTIFICATION for ${targetUser}:`);
    console.log(`   From: ${fromUser}`);
    console.log(`   Podcast: ${podcastName}`);
    console.log(`   Rating: ${rating}/10`);
    console.log(`   Message: "${message}"`);
    console.log(`   Sent via WebSocket: ${sent}`);
    console.log(`   Push subscription available: ${!!pushSubscription}`);
    
    res.json({ 
      success: true, 
      message: sent ? 'Notification sent successfully' : 'User not connected',
      notification: notification
    });
  } catch (error) {
    console.error('Error sending notification:', error);
    res.status(500).json({ error: 'Failed to send notification' });
  }
});

// --- API: add podcast ---
// --- Endpoint para recarregar todos os podcasts ---
app.post('/reload-all-podcasts', async (req, res) => {
  try {
    console.log('üîÑ Iniciando recarga de todos os podcasts...');
    
    // Get all podcasts
    const podcasts = db.prepare('SELECT * FROM podcasts').all();
    
    for (const podcast of podcasts) {
      console.log(`üîÑ Recarregando ${podcast.nome}...`);
      
      // Clear existing episodes for this podcast
      db.prepare('DELETE FROM episodios WHERE podcast_id = ?').run(podcast.id);
      
      if (podcast.nome === 'watch.tm') {
        // Use watchtm.txt file
        await loadWatchTmFromFile(podcast.id);
      } else if (podcast.nome === 'Prata da Casa') {
        // Use pratadacasa.txt file
        await loadPrataDaCasaFromFile(podcast.id);
      } else {
        // Use appropriate function to get ALL episodes
        if (podcast.plataforma === "spotify" || podcast.plataforma === "soundcloud") {
          const episodes = await getAllRssEpisodes(podcast);
          if (episodes && episodes.length > 0) {
            console.log(`üìÖ Inserindo ${episodes.length} epis√≥dios para ${podcast.nome}...`);
            for (const episode of episodes) {
              try {
                db.prepare(`
                  INSERT INTO episodios (podcast_id, numero, titulo, data_publicacao, link)
                  VALUES (?, ?, ?, ?, ?)
                `).run(podcast.id, episode.episodeNum, episode.title, episode.pubDate.toISOString(), episode.link || '');
              } catch (err) {
                console.log(`   ‚ö†Ô∏è Erro ao inserir epis√≥dio ${episode.episodeNum}: ${err.message}`);
              }
            }
            console.log(`‚úÖ ${podcast.nome} carregado: ${episodes.length} epis√≥dios`);
          }
        } else if (podcast.plataforma === "youtube") {
          const episodes = await getAllYoutubeEpisodes(podcast);
          if (episodes && episodes.length > 0) {
            console.log(`üìÖ Inserindo ${episodes.length} epis√≥dios para ${podcast.nome}...`);
            for (const episode of episodes) {
              try {
                db.prepare(`
                  INSERT INTO episodios (podcast_id, numero, titulo, data_publicacao, link)
                  VALUES (?, ?, ?, ?, ?)
                `).run(podcast.id, episode.episodeNum, episode.title, episode.pubDate.toISOString(), episode.link || '');
              } catch (err) {
                console.log(`   ‚ö†Ô∏è Erro ao inserir epis√≥dio ${episode.episodeNum}: ${err.message}`);
              }
            }
            console.log(`‚úÖ ${podcast.nome} carregado: ${episodes.length} epis√≥dios`);
          }
        }
      }
    }
    
    console.log('‚úÖ Todos os podcasts foram recarregados!');
    res.json({ success: true, message: 'Todos os podcasts foram recarregados com sucesso' });
  } catch (error) {
    console.error('‚ùå Erro ao recarregar podcasts:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

app.post('/api/podcast', upload.single('imagem'), async (req, res) => {
  console.log('Received add podcast request:', req.body);
  console.log('Uploaded file:', req.file);
  
  const { nome, link, dia_da_semana, plataforma, rss, channelId } = req.body;

  // Validation
  if (!nome || !link || !dia_da_semana) {
    return res.status(400).json({ 
      error: 'Missing required fields', 
      required: ['nome', 'link', 'dia_da_semana'] 
    });
  }

  // Check if image was uploaded
  if (!req.file) {
    return res.status(400).json({ 
      error: 'Image is required', 
      message: 'Por favor, faz upload de uma imagem para o podcast' 
    });
  }

  // Validate dia_da_semana
  const validDays = ['domingo', 'segunda', 'ter√ßa', 'quarta', 'quinta', 'sexta', 's√°bado'];
  if (!validDays.includes(dia_da_semana)) {
    return res.status(400).json({ 
      error: 'Invalid dia_da_semana', 
      valid: validDays 
    });
  }

  // Validate plataforma and required fields
  const validPlatforms = ['Spotify', 'YouTube'];
  if (!validPlatforms.includes(plataforma)) {
    return res.status(400).json({ 
      error: 'Invalid plataforma', 
      valid: validPlatforms 
    });
  }

  // Validate platform-specific fields
  if (plataforma === 'Spotify' && !rss) {
    return res.status(400).json({ 
      error: 'RSS feed is required for Spotify podcasts' 
    });
  }

  if (plataforma === 'YouTube' && !channelId) {
    return res.status(400).json({ 
      error: 'Channel ID is required for YouTube podcasts' 
    });
  }

  try {
    // Generate ID (same as default podcasts)
    const id = Buffer.from(nome).toString('base64url').slice(0, 20);
    
    // Check if podcast already exists
    const existing = db.prepare(`SELECT id FROM podcasts WHERE id = ?`).get(id);
    if (existing) {
      // Remove uploaded file if podcast already exists
      if (req.file) {
        fs.unlinkSync(req.file.path);
      }
      return res.status(409).json({ 
        error: 'Podcast already exists', 
        id: id 
      });
    }

    // Use the uploaded file name (without extension for database)
    const imagem = path.parse(req.file.filename).name;

    // Insert new podcast
    const insertPodcast = db.prepare(`
      INSERT INTO podcasts (id, nome, link, dia_da_semana, imagem, plataforma, rss, channelId)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);
    
    insertPodcast.run(id, nome, link, dia_da_semana, imagem, plataforma || null, rss || null, channelId || null);
    
    console.log(`Podcast adicionado: ${nome} (ID: ${id})`);
    console.log(`Imagem guardada: ${req.file.filename}`);
    
    // Criar objeto podcast para carregar hist√≥rico
    const newPodcast = {
      id,
      nome,
      link,
      dia_da_semana,
      imagem,
      plataforma: plataforma || null,
      rss: rss || null,
      channelId: channelId || null
    };
    
    // Carregar hist√≥rico automaticamente para Spotify/SoundCloud/YouTube
    let historyResult = null;
    if (plataforma === 'spotify' || plataforma === 'soundcloud' || plataforma === 'youtube') {
      console.log(`üîÑ Carregando hist√≥rico automaticamente para ${nome}...`);
      try {
        historyResult = await fillPodcastHistory(newPodcast);
        if (historyResult.success) {
          console.log(`‚úÖ Hist√≥rico carregado: ${historyResult.addedCount} epis√≥dios adicionados de ${historyResult.totalFound} encontrados`);
        } else {
          console.log(`‚ö†Ô∏è Erro ao carregar hist√≥rico: ${historyResult.error}`);
        }
      } catch (error) {
        console.error(`‚ùå Erro ao carregar hist√≥rico para ${nome}:`, error.message);
        historyResult = { success: false, error: error.message };
      }
    }
    
    res.json({ 
      success: true, 
      message: 'Podcast adicionado com sucesso',
      podcast: { 
        id, 
        nome, 
        link, 
        dia_da_semana, 
        imagem, 
        plataforma, 
        rss, 
        channelId,
        imageFile: req.file.filename
      },
      historyLoaded: historyResult ? historyResult.success : false,
      episodesAdded: historyResult ? historyResult.addedCount : 0,
      episodesFound: historyResult ? historyResult.totalFound : 0
    });
    
  } catch (error) {
    console.error('Error adding podcast:', error);
    
    // Remove uploaded file if there was an error
    if (req.file) {
      try {
        fs.unlinkSync(req.file.path);
      } catch (unlinkError) {
        console.error('Error removing uploaded file:', unlinkError);
      }
    }
    
    res.status(500).json({ error: 'Failed to add podcast' });
  }
});

// --- Endpoint manual de update ---
app.get('/update', async (req,res)=>{
  await updatePodcasts();
  res.send('Atualiza√ß√£o conclu√≠da!');
});

// --- Endpoint para preencher todos os hist√≥ricos ---
app.get('/fill-histories', async (req,res)=>{
  try {
    await fillAllPodcastHistories();
    res.json({ 
      success: true, 
      message: 'Hist√≥ricos preenchidos com sucesso!',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Erro ao preencher hist√≥ricos:', error);
    res.status(500).json({ 
      error: 'Erro ao preencher hist√≥ricos', 
      message: error.message 
    });
  }
});

// --- Endpoint para verificar estat√≠sticas dos epis√≥dios ---
app.get('/stats', (req,res)=>{
  try {
    const totalEpisodes = db.prepare(`SELECT COUNT(*) as count FROM episodios`).get();
    const episodesByPodcast = db.prepare(`
      SELECT p.nome, COUNT(e.id) as episode_count 
      FROM podcasts p 
      LEFT JOIN episodios e ON p.id = e.podcast_id 
      GROUP BY p.id, p.nome 
      ORDER BY episode_count DESC
    `).all();
    
    res.json({
      totalEpisodes: totalEpisodes.count,
      episodesByPodcast: episodesByPodcast,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Erro ao obter estat√≠sticas:', error);
    res.status(500).json({ error: 'Erro ao obter estat√≠sticas' });
  }
});

// --- Fun√ß√£o para limpar todos os ratings ---
function clearAllRatings() {
  console.log('üßπ Limpando todos os ratings...');
  const result = db.prepare(`DELETE FROM ratings`).run();
  console.log(`‚úÖ ${result.changes} ratings removidos`);
  return result.changes;
}

// --- Fun√ß√£o para limpar epis√≥dios duplicados e inv√°lidos ---
function cleanEpisodes() {
  console.log('üßπ Limpando epis√≥dios duplicados e inv√°lidos...');
  
  let totalRemoved = 0;
  
  // 1. Remover epis√≥dios com t√≠tulos inv√°lidos
  const invalidTitles = [
    '√öltimo epis√≥dio desconhecido',
    '',
    null,
    'undefined',
    'null'
  ];
  
  for (const title of invalidTitles) {
    const result = db.prepare(`DELETE FROM episodios WHERE titulo = ? OR titulo IS NULL`).run(title);
    totalRemoved += result.changes;
    if (result.changes > 0) {
      console.log(`   üóëÔ∏è  Removidos ${result.changes} epis√≥dios com t√≠tulo: "${title}"`);
    }
  }
  
  // 2. Remover epis√≥dios duplicados (mesmo podcast_id + numero)
  const duplicates = db.prepare(`
    SELECT podcast_id, numero, COUNT(*) as count 
    FROM episodios 
    GROUP BY podcast_id, numero 
    HAVING COUNT(*) > 1
  `).all();
  
  for (const dup of duplicates) {
    // Manter apenas o mais recente (maior ID)
    const result = db.prepare(`
      DELETE FROM episodios 
      WHERE podcast_id = ? AND numero = ? 
      AND id NOT IN (
        SELECT MAX(id) FROM episodios 
        WHERE podcast_id = ? AND numero = ?
      )
    `).run(dup.podcast_id, dup.numero, dup.podcast_id, dup.numero);
    
    totalRemoved += result.changes;
    if (result.changes > 0) {
      console.log(`   üóëÔ∏è  Removidos ${result.changes} epis√≥dios duplicados (Podcast ID: ${dup.podcast_id}, Ep: ${dup.numero})`);
    }
  }
  
  console.log(`‚úÖ Total de epis√≥dios removidos: ${totalRemoved}`);
  return totalRemoved;
}

// --- Endpoint para limpeza completa ---
app.get('/cleanup', (req,res)=>{
  try {
    console.log('üöÄ Iniciando limpeza completa...');
    
    const ratingsRemoved = clearAllRatings();
    const episodesRemoved = cleanEpisodes();
    
    res.json({
      success: true,
      message: 'Limpeza conclu√≠da com sucesso!',
      ratingsRemoved,
      episodesRemoved,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Erro na limpeza:', error);
    res.status(500).json({ 
      error: 'Erro na limpeza', 
      message: error.message 
    });
  }
});

// --- API: cleanup watch.tm specifically ---
app.get('/cleanup-watchtm', (req,res)=>{
  try {
    console.log('üöÄ Limpando epis√≥dios do watch.tm...');
    
    // Remover todos os epis√≥dios do watch.tm
    const watchtmId = 'd2F0Y2gudG0';
    const result = db.prepare(`DELETE FROM episodios WHERE podcast_id = ?`).run(watchtmId);
    
    console.log(`‚úÖ Removidos ${result.changes} epis√≥dios do watch.tm`);
    
    res.json({
      success: true,
      message: `Epis√≥dios do watch.tm limpos! Removidos: ${result.changes}`,
      episodesRemoved: result.changes,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Erro na limpeza do watch.tm:', error);
    res.status(500).json({
      error: 'Erro na limpeza do watch.tm',
      message: error.message
    });
  }
});

// --- API: reload watch.tm specifically ---
app.get('/reload-watchtm', async (req,res)=>{
  try {
    console.log('üöÄ Recarregando watch.tm com parsing correto...');
    
    // Primeiro limpar epis√≥dios existentes
    const watchtmId = 'd2F0Y2gudG0';
    const deleteResult = db.prepare(`DELETE FROM episodios WHERE podcast_id = ?`).run(watchtmId);
    console.log(`üßπ Removidos ${deleteResult.changes} epis√≥dios antigos do watch.tm`);
    
    // Buscar podcast watch.tm
    const podcast = db.prepare(`SELECT * FROM podcasts WHERE id = ?`).get(watchtmId);
    if (!podcast) {
      return res.status(404).json({ error: 'Podcast watch.tm n√£o encontrado' });
    }
    
    // Buscar epis√≥dios com parsing correto
    const episodes = await getAllYoutubeEpisodes(podcast);
    
    if (episodes && episodes.length > 0) {
      console.log(`üì• Encontrados ${episodes.length} epis√≥dios v√°lidos para watch.tm`);
      
      const insertEpisode = db.prepare(`
        INSERT OR IGNORE INTO episodios (podcast_id, numero, titulo, data_publicacao)
        VALUES (?, ?, ?, ?)
      `);
      
      let addedCount = 0;
      for (const episode of episodes) {
        const result = insertEpisode.run(
          podcast.id,
          episode.episodeNum,
          episode.title,
          episode.pubDate.toISOString()
        );
        if (result.changes > 0) addedCount++;
      }
      
      console.log(`‚úÖ Adicionados ${addedCount} novos epis√≥dios para watch.tm`);
      
      res.json({
        success: true,
        message: `Watch.tm recarregado! Adicionados ${addedCount} epis√≥dios v√°lidos`,
        episodesAdded: addedCount,
        totalFound: episodes.length,
        timestamp: new Date().toISOString()
      });
    } else {
      console.log(`‚ö†Ô∏è  Nenhum epis√≥dio v√°lido encontrado para watch.tm`);
      res.json({
        success: true,
        message: 'Nenhum epis√≥dio v√°lido encontrado para watch.tm',
        episodesAdded: 0,
        totalFound: 0,
        timestamp: new Date().toISOString()
      });
    }
    
  } catch (error) {
    console.error('Erro ao recarregar watch.tm:', error);
    res.status(500).json({
      error: 'Erro ao recarregar watch.tm',
      message: error.message
    });
  }
});

// --- API: reload Z√© Carioca specifically ---
app.get('/reload-zecarioca', async (req,res)=>{
  try {
    console.log('üöÄ Recarregando Z√© Carioca com RSS...');
    
    // Primeiro limpar epis√≥dios existentes
    const zecariocaId = 'WsOpIENhcmlvY2E';
    const deleteResult = db.prepare(`DELETE FROM episodios WHERE podcast_id = ?`).run(zecariocaId);
    console.log(`üßπ Removidos ${deleteResult.changes} epis√≥dios antigos do Z√© Carioca`);
    
    // Buscar podcast Z√© Carioca
    const podcast = db.prepare(`SELECT * FROM podcasts WHERE id = ?`).get(zecariocaId);
    if (!podcast) {
      return res.status(404).json({ error: 'Podcast Z√© Carioca n√£o encontrado' });
    }
    
    // Buscar epis√≥dios com parsing espec√≠fico
    const episodes = await getAllRssEpisodes(podcast);
    
    if (episodes && episodes.length > 0) {
      console.log(`üì• Encontrados ${episodes.length} epis√≥dios para Z√© Carioca`);
      
      const insertEpisode = db.prepare(`
        INSERT OR IGNORE INTO episodios (podcast_id, numero, titulo, data_publicacao)
        VALUES (?, ?, ?, ?)
      `);
      
      let addedCount = 0;
      for (const episode of episodes) {
        const result = insertEpisode.run(
          podcast.id,
          episode.episodeNum,
          episode.title,
          episode.pubDate.toISOString()
        );
        if (result.changes > 0) addedCount++;
      }
      
      console.log(`‚úÖ Adicionados ${addedCount} novos epis√≥dios para Z√© Carioca`);
      
      res.json({
        success: true,
        message: `Z√© Carioca recarregado! Adicionados ${addedCount} epis√≥dios`,
        episodesAdded: addedCount,
        totalFound: episodes.length,
        timestamp: new Date().toISOString()
      });
    } else {
      console.log(`‚ö†Ô∏è  Nenhum epis√≥dio encontrado para Z√© Carioca`);
      res.json({
        success: true,
        message: 'Nenhum epis√≥dio encontrado para Z√© Carioca',
        episodesAdded: 0,
        totalFound: 0,
        timestamp: new Date().toISOString()
      });
    }
    
  } catch (error) {
    console.error('Erro ao recarregar Z√© Carioca:', error);
    res.status(500).json({
      error: 'Erro ao recarregar Z√© Carioca',
      message: error.message
    });
  }
});

// --- API: reload Prata da Casa specifically ---
app.get('/reload-pratadacasa', async (req,res)=>{
  try {
    console.log('üöÄ Recarregando Prata da Casa com RSS...');
    
    // Primeiro limpar epis√≥dios existentes
    const pratadacasaId = 'UHJhdGEgZGEgQ2FzYQ'; // Base64 for "Prata da Casa"
    
    // Verificar se o podcast existe, se n√£o existir, criar
    let podcast = db.prepare(`SELECT * FROM podcasts WHERE id = ?`).get(pratadacasaId);
    if (!podcast) {
      // Criar o podcast se n√£o existir
      const insertPodcast = db.prepare(`
        INSERT INTO podcasts (id, nome, link, dia_da_semana, imagem, plataforma, rss)
        VALUES (?, ?, ?, ?, ?, ?, ?)
      `);
      insertPodcast.run(
        pratadacasaId,
        'Prata da Casa',
        'https://anchor.fm/s/1056d2710/podcast/rss',
        'quarta',
        '/img/PrataDaCasa.png',
        'spotify',
        'https://anchor.fm/s/1056d2710/podcast/rss'
      );
      podcast = db.prepare(`SELECT * FROM podcasts WHERE id = ?`).get(pratadacasaId);
    }
    const deleteResult = db.prepare(`DELETE FROM episodios WHERE podcast_id = ?`).run(pratadacasaId);
    console.log(`üßπ Removidos ${deleteResult.changes} epis√≥dios antigos do Prata da Casa`);
    
    // Buscar epis√≥dios com parsing espec√≠fico
    const episodes = await getAllRssEpisodes(podcast);
    
    if (episodes && episodes.length > 0) {
      console.log(`üì• Encontrados ${episodes.length} epis√≥dios para Prata da Casa`);
      
      const insertEpisode = db.prepare(`
        INSERT OR IGNORE INTO episodios (podcast_id, numero, titulo, data_publicacao)
        VALUES (?, ?, ?, ?)
      `);
      
      let addedCount = 0;
      for (const episode of episodes) {
        const result = insertEpisode.run(
          podcast.id,
          episode.episodeNum,
          episode.title,
          episode.pubDate.toISOString()
        );
        if (result.changes > 0) addedCount++;
      }
      
      console.log(`‚úÖ Adicionados ${addedCount} novos epis√≥dios para Prata da Casa`);
      
      res.json({
        success: true,
        message: `Prata da Casa recarregado! Adicionados ${addedCount} epis√≥dios`,
        episodesAdded: addedCount,
        totalFound: episodes.length,
        timestamp: new Date().toISOString()
      });
    } else {
      console.log(`‚ö†Ô∏è  Nenhum epis√≥dio encontrado para Prata da Casa`);
      res.json({
        success: true,
        message: 'Nenhum epis√≥dio encontrado para Prata da Casa',
        episodesAdded: 0,
        totalFound: 0,
        timestamp: new Date().toISOString()
      });
    }
    
  } catch (error) {
    console.error('Erro ao recarregar Prata da Casa:', error);
    res.status(500).json({
      error: 'Erro ao recarregar Prata da Casa',
      message: error.message
    });
  }
});

// --- API: load Velho amigo from RSS file ---
app.get('/load-velhoamigo-from-file', async (req,res)=>{
  try {
    console.log('üöÄ Carregando Velho amigo do ficheiro rss.txt...');
    
    // Verificar se o podcast existe
    const velhoamigoId = 'VmVsdG8gYW1pZ28'; // Base64 for "Velho amigo"
    let podcast = db.prepare(`SELECT * FROM podcasts WHERE id = ?`).get(velhoamigoId);
    
    if (!podcast) {
      console.log('‚ùå Podcast Velho amigo n√£o encontrado na base de dados, criando...');
      // Criar o podcast se n√£o existir
      const insertPodcast = db.prepare(`
        INSERT INTO podcasts (id, nome, link, dia_da_semana, imagem, plataforma, rss)
        VALUES (?, ?, ?, ?, ?, ?, ?)
      `);
      insertPodcast.run(
        velhoamigoId,
        'Velho amigo',
        'https://anchor.fm/s/f05045d8/podcast/rss',
        'quarta',
        '/img/VelhoAmigo.png',
        'spotify',
        'https://anchor.fm/s/f05045d8/podcast/rss'
      );
      podcast = db.prepare(`SELECT * FROM podcasts WHERE id = ?`).get(velhoamigoId);
      console.log('‚úÖ Podcast Velho amigo criado com sucesso');
    }
    
    console.log(`‚úÖ Podcast encontrado: ${podcast.nome} (ID: ${podcast.id})`);
    
    // Desativar foreign key checks temporariamente
    db.prepare(`PRAGMA foreign_keys = OFF`).run();
    console.log('üîì Foreign key checks desativados temporariamente');
    
    // Primeiro limpar epis√≥dios existentes
    const deleteResult = db.prepare(`DELETE FROM episodios WHERE podcast_id = ?`).run(velhoamigoId);
    console.log(`üßπ Removidos ${deleteResult.changes} epis√≥dios antigos do Velho amigo`);
    
    // Ler ficheiro RSS
    const rssFilePath = path.join(__dirname, 'data', 'velhoamigo.txt');
    if (!fs.existsSync(rssFilePath)) {
      return res.status(404).json({ error: 'Ficheiro velhoamigo.txt n√£o encontrado na pasta data' });
    }
    
    const rssContent = fs.readFileSync(rssFilePath, 'utf8');
    const data = await parseStringPromise(rssContent);
    const items = data.rss.channel[0].item;
    
    if (!items || items.length === 0) {
      return res.status(400).json({ error: 'Nenhum epis√≥dio encontrado no ficheiro RSS' });
    }
    
    console.log(`üìä Total de itens no ficheiro RSS: ${items.length}`);
    
    // Parsing espec√≠fico para Velho amigo
    const episodes = items.map((item, index) => {
      const title = item.title[0];
      const pubDate = new Date(item.pubDate[0]);
      
      // Extrair n√∫mero do epis√≥dio - dois formatos poss√≠veis:
      // 1. "t√≠tulo | velho amigo #XX" (epis√≥dios recentes)
      // 2. "t√≠tulo | #0.X" (epis√≥dios antigos)
      
      const velhoAmigoPattern = /^(.+?)\s*\|\s*velho amigo #(\d{1,4})$/i;
      const match = title.match(velhoAmigoPattern);
      
      if (match) {
        const episodeNum = parseInt(match[2], 10);
        const episodeTitle = match[1].trim();
        console.log(`   ‚úÖ Epis√≥dio v√°lido (formato novo): #${episodeNum} - ${episodeTitle.substring(0, 50)}...`);
        return { episodeNum, title: episodeTitle, pubDate };
      } else {
        // Tentar formato antigo: "t√≠tulo | #0.X"
        const oldPattern = /^(.+?)\s*\|\s*#0\.(\d{1,2})$/i;
        const oldMatch = title.match(oldPattern);
        
        if (oldMatch) {
          const episodeNum = parseInt(oldMatch[2], 10);
          const episodeTitle = oldMatch[1].trim();
          console.log(`   ‚úÖ Epis√≥dio v√°lido (formato antigo): #${episodeNum} - ${episodeTitle.substring(0, 50)}...`);
          return { episodeNum, title: episodeTitle, pubDate };
        } else {
          console.log(`   ‚ùå Epis√≥dio ignorado (formato inv√°lido): "${title}"`);
          // Se n√£o seguir nenhum formato, usar √≠ndice
          return { episodeNum: items.length - index, title, pubDate };
        }
      }
    });
    
    // Filtrar epis√≥dios v√°lidos
    const validEpisodes = episodes.filter(ep => ep.title && ep.title.trim() !== '');
    
    // Agrupar por data e manter apenas o mais recente por data
    const episodesByDate = {};
    validEpisodes.forEach(episode => {
      const dateKey = episode.pubDate.toISOString().split('T')[0]; // YYYY-MM-DD
      if (!episodesByDate[dateKey] || episode.pubDate > episodesByDate[dateKey].pubDate) {
        episodesByDate[dateKey] = episode;
      }
    });
    
    // Converter de volta para array e ordenar por n√∫mero do epis√≥dio
    const uniqueEpisodes = Object.values(episodesByDate);
    const sortedEpisodes = uniqueEpisodes.sort((a, b) => a.episodeNum - b.episodeNum);
    
    console.log(`üìÖ Epis√≥dios √∫nicos por data: ${uniqueEpisodes.length} (removidos ${validEpisodes.length - uniqueEpisodes.length} duplicados por data)`);
    
    console.log(`üë¥ Total de epis√≥dios Velho amigo v√°lidos: ${sortedEpisodes.length}`);
    
    // Inserir epis√≥dios na base de dados
    const insertEpisode = db.prepare(`
      INSERT OR IGNORE INTO episodios (podcast_id, numero, titulo, data_publicacao)
      VALUES (?, ?, ?, ?)
    `);
    
    let addedCount = 0;
    console.log(`üîÑ Tentando inserir ${sortedEpisodes.length} epis√≥dios...`);
    
    for (let i = 0; i < sortedEpisodes.length; i++) {
      const episode = sortedEpisodes[i];
      console.log(`üìù Inserindo epis√≥dio ${i+1}/${sortedEpisodes.length}: #${episode.episodeNum} - ${episode.title.substring(0, 50)}...`);
      
      try {
        const result = insertEpisode.run(
          velhoamigoId,
          episode.episodeNum,
          episode.title,
          episode.pubDate.toISOString()
        );
        if (result.changes > 0) addedCount++;
        console.log(`   ‚úÖ Epis√≥dio #${episode.episodeNum} inserido com sucesso`);
      } catch (error) {
        console.error(`   ‚ùå Erro ao inserir epis√≥dio #${episode.episodeNum}:`, error.message);
        throw error; // Re-throw para parar o processo
      }
    }
    
    console.log(`‚úÖ Adicionados ${addedCount} novos epis√≥dios para Velho amigo`);
    
    // Reativar foreign key checks
    db.prepare(`PRAGMA foreign_keys = ON`).run();
    console.log('üîí Foreign key checks reativados');
    
    res.json({
      success: true,
      message: `Velho amigo carregado do ficheiro! Adicionados ${addedCount} epis√≥dios`,
      episodesAdded: addedCount,
      totalFound: sortedEpisodes.length,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Erro ao carregar Velho amigo do ficheiro:', error);
    res.status(500).json({
      error: 'Erro ao carregar Velho amigo do ficheiro',
      message: error.message
    });
  }
});

// --- API: clean episodes for specific podcast ---
app.get('/clean-podcast-episodes/:podcastId', async (req,res)=>{
  try {
    const podcastId = req.params.podcastId;
    console.log(`üßπ Limpando epis√≥dios do podcast ${podcastId}...`);
    
    // Desativar foreign key checks temporariamente
    db.prepare(`PRAGMA foreign_keys = OFF`).run();
    
    // Limpar epis√≥dios existentes
    const deleteResult = db.prepare(`DELETE FROM episodios WHERE podcast_id = ?`).run(podcastId);
    console.log(`üóëÔ∏è Removidos ${deleteResult.changes} epis√≥dios do podcast ${podcastId}`);
    
    // Reativar foreign key checks
    db.prepare(`PRAGMA foreign_keys = ON`).run();
    
    res.json({
      success: true,
      message: `Epis√≥dios do podcast ${podcastId} limpos! Removidos ${deleteResult.changes} epis√≥dios`,
      episodesRemoved: deleteResult.changes,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error(`Erro ao limpar epis√≥dios do podcast ${req.params.podcastId}:`, error);
    res.status(500).json({
      error: `Erro ao limpar epis√≥dios do podcast ${req.params.podcastId}`,
      message: error.message
    });
  }
});

// --- API: clean Velho amigo duplicates ---
app.get('/clean-velhoamigo-duplicates', async (req,res)=>{
  try {
    console.log('üßπ Limpando duplicados do Velho amigo...');
    
    const velhoamigoId = 'VmVsdG8gYW1pZ28'; // Base64 for "Velho amigo"
    
    // Buscar todos os epis√≥dios do Velho amigo
    const episodes = db.prepare(`
      SELECT id, numero, titulo, data_publicacao 
      FROM episodios 
      WHERE podcast_id = ? 
      ORDER BY data_publicacao DESC
    `).all(velhoamigoId);
    
    console.log(`üìä Total de epis√≥dios encontrados: ${episodes.length}`);
    
    // Agrupar por t√≠tulo (case insensitive)
    const titleGroups = {};
    episodes.forEach(episode => {
      const titleKey = episode.titulo.toLowerCase().trim();
      if (!titleGroups[titleKey]) {
        titleGroups[titleKey] = [];
      }
      titleGroups[titleKey].push(episode);
    });
    
    console.log(`üìã T√≠tulos √∫nicos encontrados: ${Object.keys(titleGroups).length}`);
    
    // Identificar duplicados e manter apenas o mais recente
    const duplicatesToRemove = [];
    let duplicatesFound = 0;
    
    Object.values(titleGroups).forEach(group => {
      if (group.length > 1) {
        duplicatesFound += group.length - 1;
        // Manter o primeiro (mais recente) e marcar os outros para remo√ß√£o
        const toKeep = group[0];
        const toRemove = group.slice(1);
        
        console.log(`üîÑ T√≠tulo duplicado: "${toKeep.titulo}"`);
        console.log(`   ‚úÖ Manter: #${toKeep.numero} (${toKeep.data_publicacao})`);
        
        toRemove.forEach(episode => {
          console.log(`   ‚ùå Remover: #${episode.numero} (${episode.data_publicacao})`);
          duplicatesToRemove.push(episode.id);
        });
      }
    });
    
    console.log(`üîç Duplicados encontrados: ${duplicatesFound}`);
    
    if (duplicatesToRemove.length === 0) {
      return res.json({
        success: true,
        message: 'Nenhum duplicado encontrado no Velho amigo',
        duplicatesRemoved: 0,
        totalEpisodes: episodes.length,
        uniqueTitles: Object.keys(titleGroups).length
      });
    }
    
    // Remover duplicados
    const deleteStmt = db.prepare(`DELETE FROM episodios WHERE id = ?`);
    let removedCount = 0;
    
    for (const episodeId of duplicatesToRemove) {
      try {
        const result = deleteStmt.run(episodeId);
        if (result.changes > 0) {
          removedCount++;
        }
      } catch (error) {
        console.error(`‚ùå Erro ao remover epis√≥dio ${episodeId}:`, error.message);
      }
    }
    
    console.log(`‚úÖ Removidos ${removedCount} epis√≥dios duplicados`);
    
    res.json({
      success: true,
      message: `Velho amigo limpo! Removidos ${removedCount} duplicados`,
      duplicatesRemoved: removedCount,
      totalEpisodes: episodes.length,
      uniqueTitles: Object.keys(titleGroups).length,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Erro ao limpar duplicados do Velho amigo:', error);
    res.status(500).json({
      error: 'Erro ao limpar duplicados do Velho amigo',
      message: error.message
    });
  }
});

// --- API: clean episodes and reload ---
app.get('/reload-all-episodes', async (req,res)=>{
  try {
    console.log('üßπ Limpando TODOS os epis√≥dios e recarregando...');
    
    // Desativar foreign key checks temporariamente
    db.prepare(`PRAGMA foreign_keys = OFF`).run();
    console.log('üîì Foreign key checks desativados temporariamente');
    
    // Deletar apenas epis√≥dios e ratings
    const deleteRatings = db.prepare(`DELETE FROM ratings`).run();
    const deleteEpisodes = db.prepare(`DELETE FROM episodios`).run();
    
    console.log(`üóëÔ∏è Removidos ${deleteRatings.changes} ratings`);
    console.log(`üóëÔ∏è Removidos ${deleteEpisodes.changes} epis√≥dios`);
    
    // Reativar foreign key checks
    db.prepare(`PRAGMA foreign_keys = ON`).run();
    console.log('üîí Foreign key checks reativados');
    
    // Recarregar todos os epis√≥dios
    console.log('üîÑ Recarregando epis√≥dios de todos os podcasts...');
    await updatePodcasts();
    
    res.json({
      success: true,
      message: `Epis√≥dios limpos e recarregados! Removidos ${deleteRatings.changes} ratings e ${deleteEpisodes.changes} epis√≥dios`,
      removed: {
        ratings: deleteRatings.changes,
        episodes: deleteEpisodes.changes
      },
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Erro ao recarregar epis√≥dios:', error);
    res.status(500).json({
      error: 'Erro ao recarregar epis√≥dios',
      message: error.message
    });
  }
});

// --- API: update RSS feeds in database ---
app.get('/update-rss-feeds', async (req,res)=>{
  try {
    console.log('üîÑ Atualizando RSS feeds na base de dados...');
    
    const podcasts = [
      { nome: "watch.tm", rss: "https://anchor.fm/s/df67421c/podcast/rss" },
      { nome: "√† noite mata", rss: "https://anchor.fm/s/db97b450/podcast/rss" },
      { nome: "desnorte", rss: "https://feeds.soundcloud.com/users/soundcloud:users:795862234/sounds.rss" },
      { nome: "Z√© Carioca", rss: "https://anchor.fm/s/ea5b58fc/podcast/rss" },
      { nome: "Cubinho", rss: "https://anchor.fm/s/8e11a8d0/podcast/rss" },
      { nome: "Prata da Casa", rss: "https://anchor.fm/s/1056d2710/podcast/rss" },
      { nome: "Contraluz", rss: "https://anchor.fm/s/fb86963c/podcast/rss" },
      { nome: "Trocadilho", rss: "https://anchor.fm/s/3d61c0b4/podcast/rss" }
    ];
    
    const updateRss = db.prepare(`UPDATE podcasts SET rss = ? WHERE nome = ?`);
    let updatedCount = 0;
    
    for (const podcast of podcasts) {
      const result = updateRss.run(podcast.rss, podcast.nome);
      if (result.changes > 0) {
        console.log(`‚úÖ RSS atualizado para ${podcast.nome}: ${podcast.rss}`);
        updatedCount++;
      } else {
        console.log(`‚ö†Ô∏è Podcast ${podcast.nome} n√£o encontrado na base de dados`);
      }
    }
    
    res.json({
      success: true,
      message: `RSS feeds atualizados! ${updatedCount} podcasts atualizados`,
      updated: updatedCount,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Erro ao atualizar RSS feeds:', error);
    res.status(500).json({
      error: 'Erro ao atualizar RSS feeds',
      message: error.message
    });
  }
});

// --- API: load all episodes from RSS for specific podcast ---
app.get('/load-all-episodes/:podcastName', async (req,res)=>{
  try {
    const podcastName = req.params.podcastName;
    console.log(`üöÄ Carregando TODOS os epis√≥dios de ${podcastName} do RSS...`);
    
    // Buscar o podcast na base de dados
    const podcast = db.prepare(`SELECT * FROM podcasts WHERE nome = ?`).get(podcastName);
    
    if (!podcast) {
      return res.status(404).json({ error: `Podcast ${podcastName} n√£o encontrado na base de dados` });
    }
    
    if (!podcast.rss) {
      return res.status(400).json({ error: `Podcast ${podcastName} n√£o tem RSS feed configurado` });
    }
    
    console.log(`‚úÖ Podcast encontrado: ${podcast.nome} (RSS: ${podcast.rss})`);
    
    // Desativar foreign key checks temporariamente
    db.prepare(`PRAGMA foreign_keys = OFF`).run();
    console.log('üîì Foreign key checks desativados temporariamente');
    
    // Limpar epis√≥dios existentes
    const deleteResult = db.prepare(`DELETE FROM episodios WHERE podcast_id = ?`).run(podcast.id);
    console.log(`üßπ Removidos ${deleteResult.changes} epis√≥dios antigos de ${podcastName}`);
    
    // Buscar epis√≥dios do RSS
    let episodes = [];
    
    if (podcast.plataforma === "spotify" || podcast.plataforma === "soundcloud") {
      episodes = await getAllRssEpisodes(podcast);
    } else if (podcast.plataforma === "youtube") {
      episodes = await getAllYoutubeEpisodes(podcast);
    }
    
    if (!episodes || episodes.length === 0) {
      db.prepare(`PRAGMA foreign_keys = ON`).run();
      return res.status(400).json({ error: `Nenhum epis√≥dio encontrado para ${podcastName}` });
    }
    
    console.log(`üìä Total de epis√≥dios encontrados: ${episodes.length}`);
    
    // Inserir epis√≥dios na base de dados
    const insertEpisode = db.prepare(`
      INSERT OR IGNORE INTO episodios (podcast_id, numero, titulo, data_publicacao)
      VALUES (?, ?, ?, ?)
    `);
    
    let addedCount = 0;
    console.log(`üîÑ Inserindo ${episodes.length} epis√≥dios...`);
    
    for (let i = 0; i < episodes.length; i++) {
      const episode = episodes[i];
      console.log(`üìù Inserindo epis√≥dio ${i+1}/${episodes.length}: #${episode.episodeNum} - ${episode.title.substring(0, 50)}...`);
      
      try {
        const result = insertEpisode.run(
          podcast.id,
          episode.episodeNum,
          episode.title,
          episode.pubDate.toISOString()
        );
        if (result.changes > 0) addedCount++;
        console.log(`   ‚úÖ Epis√≥dio #${episode.episodeNum} inserido com sucesso`);
      } catch (error) {
        console.error(`   ‚ùå Erro ao inserir epis√≥dio #${episode.episodeNum}:`, error.message);
        throw error;
      }
    }
    
    console.log(`‚úÖ Adicionados ${addedCount} novos epis√≥dios para ${podcastName}`);
    
    // Reativar foreign key checks
    db.prepare(`PRAGMA foreign_keys = ON`).run();
    console.log('üîí Foreign key checks reativados');
    
    res.json({
      success: true,
      message: `${podcastName} carregado do RSS! Adicionados ${addedCount} epis√≥dios`,
      episodesAdded: addedCount,
      totalFound: episodes.length,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error(`Erro ao carregar epis√≥dios de ${req.params.podcastName}:`, error);
    res.status(500).json({
      error: `Erro ao carregar epis√≥dios de ${req.params.podcastName}`,
      message: error.message
    });
  }
});

// --- API: force remove Velho amigo duplicates ---
app.get('/force-remove-velho-amigo-duplicates', async (req,res)=>{
  try {
    console.log('üîß Removendo FOR√áADAMENTE duplicados do Velho amigo...');
    
    // Buscar todos os podcasts "Velho amigo"
    const velhoAmigoPodcasts = db.prepare(`
      SELECT id, nome, plataforma, link, dia_da_semana 
      FROM podcasts 
      WHERE nome = 'Velho amigo'
    `).all();
    
    console.log(`üìä Encontrados ${velhoAmigoPodcasts.length} podcasts "Velho amigo"`);
    
    if (velhoAmigoPodcasts.length <= 1) {
      return res.json({
        success: true,
        message: 'Nenhum duplicado encontrado no Velho amigo',
        found: velhoAmigoPodcasts.length
      });
    }
    
    // Encontrar o que tem plataforma = 'spotify' e link correto
    const spotifyVelhoAmigo = velhoAmigoPodcasts.find(p => 
      p.plataforma === 'spotify' && 
      p.link.includes('anchor.fm')
    );
    
    const others = velhoAmigoPodcasts.filter(p => 
      !(p.plataforma === 'spotify' && p.link.includes('anchor.fm'))
    );
    
    if (!spotifyVelhoAmigo) {
      return res.json({
        success: false,
        message: 'Nenhum Velho amigo com plataforma Spotify e link correto encontrado',
        found: velhoAmigoPodcasts.length
      });
    }
    
    console.log(`‚úÖ Mantendo: ${spotifyVelhoAmigo.id} (${spotifyVelhoAmigo.plataforma})`);
    console.log(`‚ùå Removendo: ${others.length} duplicados`);
    
    // Desativar foreign key checks temporariamente
    db.prepare(`PRAGMA foreign_keys = OFF`).run();
    
    // Remover epis√≥dios e ratings dos duplicados
    let removedEpisodes = 0;
    let removedRatings = 0;
    
    for (const duplicate of others) {
      const deleteRatings = db.prepare(`DELETE FROM ratings WHERE podcast_id = ?`).run(duplicate.id);
      const deleteEpisodes = db.prepare(`DELETE FROM episodios WHERE podcast_id = ?`).run(duplicate.id);
      const deletePodcast = db.prepare(`DELETE FROM podcasts WHERE id = ?`).run(duplicate.id);
      
      removedRatings += deleteRatings.changes;
      removedEpisodes += deleteEpisodes.changes;
      
      console.log(`üóëÔ∏è Removido podcast ${duplicate.id}: ${deleteEpisodes.changes} epis√≥dios, ${deleteRatings.changes} ratings`);
    }
    
    // Reativar foreign key checks
    db.prepare(`PRAGMA foreign_keys = ON`).run();
    
    res.json({
      success: true,
      message: `Duplicados do Velho amigo removidos FOR√áADAMENTE! Mantido: ${spotifyVelhoAmigo.id}, Removidos: ${others.length} podcasts`,
      kept: spotifyVelhoAmigo.id,
      removed: {
        podcasts: others.length,
        episodes: removedEpisodes,
        ratings: removedRatings
      },
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Erro ao remover duplicados do Velho amigo:', error);
    res.status(500).json({
      error: 'Erro ao remover duplicados do Velho amigo',
      message: error.message
    });
  }
});

// --- API: check for duplicate Velho amigo ---
app.get('/check-velho-amigo-duplicates', async (req,res)=>{
  try {
    // Verificar na base de dados
    const dbPodcasts = db.prepare(`
      SELECT id, nome, plataforma, link, dia_da_semana 
      FROM podcasts 
      WHERE nome = 'Velho amigo'
    `).all();
    
    // Verificar na lista de podcasts do c√≥digo
    const codePodcasts = [
      { nome: "Velho amigo", link: "https://anchor.fm/s/f05045d8/podcast/rss", dia: "quarta", img: "/img/VelhoAmigo.png", plataforma:"spotify", rss:"https://anchor.fm/s/f05045d8/podcast/rss" }
    ];
    
    res.json({
      success: true,
      database: {
        count: dbPodcasts.length,
        podcasts: dbPodcasts
      },
      code: {
        count: codePodcasts.length,
        podcasts: codePodcasts
      },
      hasDuplicates: dbPodcasts.length > 1
    });
    
  } catch (error) {
    res.status(500).json({
      error: 'Erro ao verificar duplicados do Velho amigo',
      message: error.message
    });
  }
});

// --- API: list all podcasts ---
app.get('/list-all-podcasts', async (req,res)=>{
  try {
    const allPodcasts = db.prepare(`
      SELECT id, nome, plataforma, link, dia_da_semana 
      FROM podcasts 
      ORDER BY nome
    `).all();
    
    res.json({
      success: true,
      podcasts: allPodcasts,
      count: allPodcasts.length
    });
    
  } catch (error) {
    res.status(500).json({
      error: 'Erro ao listar todos os podcasts',
      message: error.message
    });
  }
});

// --- API: list all Velho amigo podcasts ---
app.get('/list-velho-amigo-podcasts', async (req,res)=>{
  try {
    const velhoAmigoPodcasts = db.prepare(`
      SELECT id, nome, plataforma, link, dia_da_semana 
      FROM podcasts 
      WHERE nome = 'Velho amigo'
    `).all();
    
    res.json({
      success: true,
      podcasts: velhoAmigoPodcasts,
      count: velhoAmigoPodcasts.length
    });
    
  } catch (error) {
    res.status(500).json({
      error: 'Erro ao listar podcasts Velho amigo',
      message: error.message
    });
  }
});

// --- API: remove duplicate Velho amigo ---
app.get('/fix-velho-amigo-duplicates', async (req,res)=>{
  try {
    console.log('üîß Removendo duplicados do Velho amigo...');
    
    // Buscar todos os podcasts "Velho amigo"
    const velhoAmigoPodcasts = db.prepare(`
      SELECT id, nome, plataforma 
      FROM podcasts 
      WHERE nome = 'Velho amigo'
    `).all();
    
    console.log(`üìä Encontrados ${velhoAmigoPodcasts.length} podcasts "Velho amigo"`);
    
    if (velhoAmigoPodcasts.length <= 1) {
      return res.json({
        success: true,
        message: 'Nenhum duplicado encontrado no Velho amigo',
        found: velhoAmigoPodcasts.length
      });
    }
    
    // Encontrar o que tem plataforma = 'spotify'
    const spotifyVelhoAmigo = velhoAmigoPodcasts.find(p => p.plataforma === 'spotify');
    const others = velhoAmigoPodcasts.filter(p => p.plataforma !== 'spotify');
    
    if (!spotifyVelhoAmigo) {
      return res.json({
        success: false,
        message: 'Nenhum Velho amigo com plataforma Spotify encontrado',
        found: velhoAmigoPodcasts.length
      });
    }
    
    console.log(`‚úÖ Mantendo: ${spotifyVelhoAmigo.id} (${spotifyVelhoAmigo.plataforma})`);
    console.log(`‚ùå Removendo: ${others.length} duplicados`);
    
    // Desativar foreign key checks temporariamente
    db.prepare(`PRAGMA foreign_keys = OFF`).run();
    
    // Remover epis√≥dios e ratings dos duplicados
    let removedEpisodes = 0;
    let removedRatings = 0;
    
    for (const duplicate of others) {
      const deleteRatings = db.prepare(`DELETE FROM ratings WHERE podcast_id = ?`).run(duplicate.id);
      const deleteEpisodes = db.prepare(`DELETE FROM episodios WHERE podcast_id = ?`).run(duplicate.id);
      const deletePodcast = db.prepare(`DELETE FROM podcasts WHERE id = ?`).run(duplicate.id);
      
      removedRatings += deleteRatings.changes;
      removedEpisodes += deleteEpisodes.changes;
      
      console.log(`üóëÔ∏è Removido podcast ${duplicate.id}: ${deleteEpisodes.changes} epis√≥dios, ${deleteRatings.changes} ratings`);
    }
    
    // Reativar foreign key checks
    db.prepare(`PRAGMA foreign_keys = ON`).run();
    
    res.json({
      success: true,
      message: `Duplicados do Velho amigo removidos! Mantido: ${spotifyVelhoAmigo.id}, Removidos: ${others.length} podcasts`,
      kept: spotifyVelhoAmigo.id,
      removed: {
        podcasts: others.length,
        episodes: removedEpisodes,
        ratings: removedRatings
      },
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Erro ao remover duplicados do Velho amigo:', error);
    res.status(500).json({
      error: 'Erro ao remover duplicados do Velho amigo',
      message: error.message
    });
  }
});

// --- API: clean entire database ---
app.get('/clean-database', async (req,res)=>{
  try {
    console.log('üßπ Limpando TODA a base de dados...');
    
    // Desativar foreign key checks temporariamente
    db.prepare(`PRAGMA foreign_keys = OFF`).run();
    console.log('üîì Foreign key checks desativados temporariamente');
    
    // Deletar TODOS os dados
    const deleteRatings = db.prepare(`DELETE FROM ratings`).run();
    const deleteEpisodes = db.prepare(`DELETE FROM episodios`).run();
    const deletePodcasts = db.prepare(`DELETE FROM podcasts`).run();
    const deleteSubscriptions = db.prepare(`DELETE FROM push_subscriptions`).run();
    
    console.log(`üóëÔ∏è Removidos ${deleteRatings.changes} ratings`);
    console.log(`üóëÔ∏è Removidos ${deleteEpisodes.changes} epis√≥dios`);
    console.log(`üóëÔ∏è Removidos ${deletePodcasts.changes} podcasts`);
    console.log(`üóëÔ∏è Removidos ${deleteSubscriptions.changes} subscri√ß√µes`);
    
    // Reativar foreign key checks
    db.prepare(`PRAGMA foreign_keys = ON`).run();
    console.log('üîí Foreign key checks reativados');
    
    res.json({
      success: true,
      message: `Base de dados limpa! Removidos ${deleteRatings.changes + deleteEpisodes.changes + deletePodcasts.changes + deleteSubscriptions.changes} registos`,
      removed: {
        ratings: deleteRatings.changes,
        episodes: deleteEpisodes.changes,
        podcasts: deletePodcasts.changes,
        subscriptions: deleteSubscriptions.changes
      },
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Erro ao limpar base de dados:', error);
    res.status(500).json({
      error: 'Erro ao limpar base de dados',
      message: error.message
    });
  }
});

// --- API: clean Velho amigo episodes ---
app.get('/clean-velhoamigo-episodes', async (req,res)=>{
  try {
    console.log('üßπ Limpando TODOS os epis√≥dios do Velho amigo...');
    
    const velhoamigoId = 'VmVsdG8gYW1pZ28'; // Base64 for "Velho amigo"
    
    // Desativar foreign key checks temporariamente
    db.prepare(`PRAGMA foreign_keys = OFF`).run();
    console.log('üîì Foreign key checks desativados temporariamente');
    
    // Deletar TODOS os epis√≥dios do Velho amigo
    const deleteResult = db.prepare(`DELETE FROM episodios WHERE podcast_id = ?`).run(velhoamigoId);
    console.log(`üóëÔ∏è Removidos ${deleteResult.changes} epis√≥dios do Velho amigo`);
    
    // Reativar foreign key checks
    db.prepare(`PRAGMA foreign_keys = ON`).run();
    console.log('üîí Foreign key checks reativados');
    
    res.json({
      success: true,
      message: `Velho amigo limpo! Removidos ${deleteResult.changes} epis√≥dios`,
      episodesRemoved: deleteResult.changes,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Erro ao limpar epis√≥dios do Velho amigo:', error);
    res.status(500).json({
      error: 'Erro ao limpar epis√≥dios do Velho amigo',
      message: error.message
    });
  }
});

// --- API: debug Velho amigo episodes ---
app.get('/debug-velhoamigo-episodes', async (req,res)=>{
  try {
    const velhoamigoId = 'VmVsdG8gYW1pZ28'; // Base64 for "Velho amigo"
    
    const episodes = db.prepare(`
      SELECT numero, titulo, data_publicacao 
      FROM episodios 
      WHERE podcast_id = ? 
      ORDER BY numero ASC
      LIMIT 20
    `).all(velhoamigoId);
    
    res.json({
      success: true,
      episodes: episodes,
      total: episodes.length
    });
    
  } catch (error) {
    res.status(500).json({
      error: 'Erro ao buscar epis√≥dios do Velho amigo',
      message: error.message
    });
  }
});

// --- API: load Prata da Casa from RSS file ---
app.get('/load-pratadacasa-from-file', async (req,res)=>{
  try {
    console.log('üöÄ Carregando Prata da Casa do ficheiro rss.txt...');
    
    // Verificar se o podcast existe
    const pratadacasaId = 'UHJhdGEgZGEgQ2FzYQ'; // Base64 for "Prata da Casa"
    let podcast = db.prepare(`SELECT * FROM podcasts WHERE id = ?`).get(pratadacasaId);
    
    if (!podcast) {
      console.log('‚ùå Podcast Prata da Casa n√£o encontrado na base de dados');
      return res.status(404).json({ 
        error: 'Podcast Prata da Casa n√£o encontrado',
        message: 'O podcast precisa existir na tabela podcasts primeiro'
      });
    }
    
    console.log(`‚úÖ Podcast encontrado: ${podcast.nome} (ID: ${podcast.id})`);
    
    // Desativar foreign key checks temporariamente
    db.prepare(`PRAGMA foreign_keys = OFF`).run();
    console.log('üîì Foreign key checks desativados temporariamente');
    
    // Primeiro limpar epis√≥dios existentes
    const deleteResult = db.prepare(`DELETE FROM episodios WHERE podcast_id = ?`).run(pratadacasaId);
    console.log(`üßπ Removidos ${deleteResult.changes} epis√≥dios antigos do Prata da Casa`);
    
    // Ler ficheiro RSS
    const rssFilePath = path.join(__dirname, 'data', 'pratadacasa.txt');
    if (!fs.existsSync(rssFilePath)) {
      return res.status(404).json({ error: 'Ficheiro pratadacasa.txt n√£o encontrado na pasta data' });
    }
    
    const rssContent = fs.readFileSync(rssFilePath, 'utf8');
    const data = await parseStringPromise(rssContent);
    const items = data.rss.channel[0].item;
    
    if (!items || items.length === 0) {
      return res.status(400).json({ error: 'Nenhum epis√≥dio encontrado no ficheiro RSS' });
    }
    
    console.log(`üìä Total de itens no ficheiro RSS: ${items.length}`);
    
    // Parsing espec√≠fico para Prata da Casa
    const episodes = items.map((item, index) => {
      const title = item.title[0];
      const pubDate = new Date(item.pubDate[0]);
      
      // Extrair n√∫mero do epis√≥dio do formato "Prata da Casa #XX - T√≠tulo" (com ou sem zeros √† frente)
      const prataDaCasaPattern = /^Prata da Casa #(\d{1,4})\s*-\s*(.+)$/i;
      const match = title.match(prataDaCasaPattern);
      
      if (match) {
        const episodeNum = parseInt(match[1], 10); // parseInt remove zeros √† frente automaticamente
        const episodeTitle = match[2].trim();
        console.log(`   ‚úÖ Epis√≥dio v√°lido: #${episodeNum} - ${episodeTitle.substring(0, 50)}...`);
        return { episodeNum, title: episodeTitle, pubDate };
      } else {
        console.log(`   ‚ùå Epis√≥dio ignorado (formato inv√°lido): "${title}"`);
        // Se n√£o seguir o formato espec√≠fico, usar √≠ndice
        return { episodeNum: items.length - index, title, pubDate };
      }
    });
    
    // Filtrar epis√≥dios v√°lidos e ordenar
    const validEpisodes = episodes.filter(ep => ep.title && ep.title.trim() !== '');
    const sortedEpisodes = validEpisodes.sort((a, b) => a.episodeNum - b.episodeNum);
    
    console.log(`üíé Total de epis√≥dios Prata da Casa v√°lidos: ${sortedEpisodes.length}`);
    
    // Inserir epis√≥dios na base de dados
    const insertEpisode = db.prepare(`
      INSERT OR IGNORE INTO episodios (podcast_id, numero, titulo, data_publicacao)
      VALUES (?, ?, ?, ?)
    `);
    
    let addedCount = 0;
    console.log(`üîÑ Tentando inserir ${sortedEpisodes.length} epis√≥dios...`);
    
    for (let i = 0; i < sortedEpisodes.length; i++) {
      const episode = sortedEpisodes[i];
      console.log(`üìù Inserindo epis√≥dio ${i+1}/${sortedEpisodes.length}: #${episode.episodeNum} - ${episode.title.substring(0, 50)}...`);
      
      try {
        const result = insertEpisode.run(
          pratadacasaId,
          episode.episodeNum,
          episode.title,
          episode.pubDate.toISOString()
        );
        if (result.changes > 0) addedCount++;
        console.log(`   ‚úÖ Epis√≥dio #${episode.episodeNum} inserido com sucesso`);
      } catch (error) {
        console.error(`   ‚ùå Erro ao inserir epis√≥dio #${episode.episodeNum}:`, error.message);
        throw error; // Re-throw para parar o processo
      }
    }
    
    console.log(`‚úÖ Adicionados ${addedCount} novos epis√≥dios para Prata da Casa`);
    
    // Reativar foreign key checks
    db.prepare(`PRAGMA foreign_keys = ON`).run();
    console.log('üîí Foreign key checks reativados');
    
    res.json({
      success: true,
      message: `Prata da Casa carregado do ficheiro! Adicionados ${addedCount} epis√≥dios`,
      episodesAdded: addedCount,
      totalFound: sortedEpisodes.length,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Erro ao carregar Prata da Casa do ficheiro:', error);
    res.status(500).json({
      error: 'Erro ao carregar Prata da Casa do ficheiro',
      message: error.message
    });
  }
});

// --- API: load watch.tm from RSS file ---
app.get('/load-watchtm-from-file', async (req,res)=>{
  try {
    console.log('üöÄ Carregando watch.tm do ficheiro rss.txt...');
    
    // Primeiro limpar epis√≥dios existentes
    const watchtmId = 'd2F0Y2gudG0';
    const deleteResult = db.prepare(`DELETE FROM episodios WHERE podcast_id = ?`).run(watchtmId);
    console.log(`üßπ Removidos ${deleteResult.changes} epis√≥dios antigos do watch.tm`);
    
    // Ler ficheiro RSS
    const rssFilePath = path.join(__dirname, 'data', 'rss.txt');
    
    if (!fs.existsSync(rssFilePath)) {
      return res.status(404).json({ error: 'Ficheiro rss.txt n√£o encontrado na pasta data' });
    }
    
    const rssContent = fs.readFileSync(rssFilePath, 'utf8');
    const data = await parseStringPromise(rssContent);
    const items = data.rss.channel[0].item;
    
    if (!items || items.length === 0) {
      return res.status(400).json({ error: 'Nenhum epis√≥dio encontrado no ficheiro RSS' });
    }
    
    console.log(`üìä Total de itens no ficheiro RSS: ${items.length}`);
    
    // Processar epis√≥dios
    const episodes = items.map((item, index) => {
      const title = item.title[0];
      const pubDate = new Date(item.pubDate[0]);
      
      // Extrair n√∫mero do epis√≥dio do FIM do t√≠tulo (sempre no final)
      const match = title.match(/#(\d{1,4})$/);
      const episodeNum = match ? parseInt(match[1], 10) : (items.length - index);
      
      return { episodeNum, title, pubDate };
    });
    
    // Ordenar por n√∫mero do epis√≥dio (crescente)
    const sortedEpisodes = episodes.sort((a, b) => a.episodeNum - b.episodeNum);
    
    // Inserir na base de dados
    const insertEpisode = db.prepare(`
      INSERT OR IGNORE INTO episodios (podcast_id, numero, titulo, data_publicacao)
      VALUES (?, ?, ?, ?)
    `);
    
    let addedCount = 0;
    for (const episode of sortedEpisodes) {
      const result = insertEpisode.run(
        watchtmId,
        episode.episodeNum,
        episode.title,
        episode.pubDate.toISOString()
      );
      if (result.changes > 0) addedCount++;
    }
    
    console.log(`‚úÖ Adicionados ${addedCount} novos epis√≥dios para watch.tm`);
    
    res.json({
      success: true,
      message: `Watch.tm carregado do ficheiro! Adicionados ${addedCount} epis√≥dios`,
      episodesAdded: addedCount,
      totalFound: sortedEpisodes.length,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Erro ao carregar watch.tm do ficheiro:', error);
    res.status(500).json({
      error: 'Erro ao carregar watch.tm do ficheiro',
      message: error.message
    });
  }
});


// For Vercel deployment
if (process.env.NODE_ENV === 'production') {
  // Export the app for Vercel
  module.exports = app;
} else {
  // Start server locally
  server.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
    console.log(`WebSocket server running on ws://localhost:${PORT}`);
    console.log('üì° Epis√≥dios ser√£o verificados quando a p√°gina for aberta');
  });
}
